% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{CC3DSimUtils Documentation}
\date{March 25, 2013}
\release{1.0}
\author{Margriet Palm}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{CC3DSimUtils::doc}


Contents:


\chapter{Prerequisites}
\label{Preq:welcome-to-mimbsimutils-documentation}\label{Preq:prerequisites}\label{Preq::doc}
MIMBSimUtils depends on a number of python packages which must be installed.


\section{Numpy}
\label{Preq:numpy}
Numpy is a package for numerical computation in python and it provides a very powerful array object. Download \href{http://sourceforge.net/projects/numpy/files/}{numpy} and install it according to the instructions. Alternatively, numpy can be installed using pip:

\begin{Verbatim}[commandchars=\\\{\}]
pip install numpy
\end{Verbatim}


\section{Scipy}
\label{Preq:scipy}
Scipy is a python package of scientific software, which heavily depends on numpy arrays. Download \href{http://sourceforge.net/projects/scipy/files/}{scipy} and follow the installation instructions. Alternatively, scipy can be installed using pip:

\begin{Verbatim}[commandchars=\\\{\}]
pip install scipy
\end{Verbatim}


\section{Python imaging library}
\label{Preq:python-imaging-library}
The python imaging library (PIL) is an image processing package for python. Download \href{http://www.pythonware.com/products/pil/\#pil117}{PIL} and install according to the instruction included in the package:

\begin{Verbatim}[commandchars=\\\{\}]
pip install pil
\end{Verbatim}


\section{Mahotas and Pymorph}
\label{Preq:mahotas-and-pymorph}
Mahotas and Pymorph are two packages we use for image analysis. These packages can be downloaded from \href{https://pypi.python.org/pypi/mahotas}{here} and \href{https://pypi.python.org/pypi/pymorph}{here}. Alternatively they can be installed using pip:

\begin{Verbatim}[commandchars=\\\{\}]
pip install mahotas
pip install pymorph
\end{Verbatim}


\chapter{AnalysisUtils}
\label{AnalysisUtils:analysisutils}\label{AnalysisUtils::doc}

\section{Compactness}
\label{AnalysisUtils:compactness}\index{getCompactness() (in module AnalysisUtils)}

\begin{fulllineitems}
\phantomsection\label{AnalysisUtils:AnalysisUtils.getCompactness}\pysiglinewithargsret{\code{AnalysisUtils.}\bfcode{getCompactness}}{\emph{sigma}, \emph{minval=0}}{}
Calculate compactness of a morphology: $\frac{A_{\text{area}}}{A_{\text{convex hull}}}$ .
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{sigma} -- numpy array with cell id's

\item {} 
\textbf{minval} (\emph{int}) -- minimum cell id for non medium pixels

\end{itemize}

\item[{Returns}] \leavevmode
compactness

\end{description}\end{quote}

\end{fulllineitems}

\index{getLCC() (in module AnalysisUtils)}

\begin{fulllineitems}
\phantomsection\label{AnalysisUtils:AnalysisUtils.getLCC}\pysiglinewithargsret{\code{AnalysisUtils.}\bfcode{getLCC}}{\emph{sigma}}{}
Find largest connected component of an image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{sigma} -- numpy array with cell id's

\item[{Returns}] \leavevmode
image with largest connected component

\end{description}\end{quote}

\end{fulllineitems}



\section{Order parameter}
\label{AnalysisUtils:order-parameter}
The \href{http://en.wikipedia.org/wiki/Liquid\_crystal\#Order\_parameter}{order parameter} describes the orientational order of a liquid crystal : $s = \left \langle \text{cos}(2 \theta)\right \rangle$; $s = 0\;$ for a random sample and $s = 1\;$ for an isotropic sample. $\theta\;$ is the angle between the cell direction and the \href{http://en.wikipedia.org/wiki/Liquid\_crystal\#Director}{director}. The director is a dimensionless unit vector. It represents the direction of preferred orientation of cells in the neighborhood of any point. Because there is no physical polarity along the director axis, n and -n are fully equivalent. Here the neighborhood is defined as a circle with center com and radius r.
\index{getDirector() (in module AnalysisUtils)}

\begin{fulllineitems}
\phantomsection\label{AnalysisUtils:AnalysisUtils.getDirector}\pysiglinewithargsret{\code{AnalysisUtils.}\bfcode{getDirector}}{\emph{com}, \emph{r}, \emph{sigma}, \emph{angles}}{}
Find the director of the center of mass of a cell.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{com} -- center of mass of the cell (x,y)

\item {} 
\textbf{r} (\emph{number}) -- radius of neighborhood

\item {} 
\textbf{sigma} -- numpy array with cell id's

\item {} 
\textbf{angles} -- numpy array with cell angles (radians)

\end{itemize}

\item[{Returns}] \leavevmode
director (radians)

\end{description}\end{quote}

\end{fulllineitems}

\index{getOrderParameter() (in module AnalysisUtils)}

\begin{fulllineitems}
\phantomsection\label{AnalysisUtils:AnalysisUtils.getOrderParameter}\pysiglinewithargsret{\code{AnalysisUtils.}\bfcode{getOrderParameter}}{\emph{sigma}, \emph{angles}, \emph{r}}{}
Calculate order parameter for a morphology using the cpm grid data. When the requested radius is larger than the maximum radius of the grid, the global order parameter is calculated with {\hyperref[AnalysisUtils:AnalysisUtils.getGlobalOrderParameter]{\code{getGlobalOrderParameter()}}}; otherwise the local order parameter is calculated with {\hyperref[AnalysisUtils:AnalysisUtils.getLocalOrderParameter]{\code{getLocalOrderParameter()}}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{sigma} -- numpy array with cell id's

\item {} 
\textbf{angles} -- numpy array with cell angles (radians)

\item {} 
\textbf{r} (\emph{int}) -- radius of neighborhood

\end{itemize}

\end{description}\end{quote}


\strong{See Also:}


{\hyperref[AnalysisUtils:AnalysisUtils.getLocalOrderParameter]{\code{getLocalOrderParameter()}}}, {\hyperref[AnalysisUtils:AnalysisUtils.getGlobalOrderParameter]{\code{getGlobalOrderParameter()}}}



\end{fulllineitems}

\index{getLocalOrderParameter() (in module AnalysisUtils)}

\begin{fulllineitems}
\phantomsection\label{AnalysisUtils:AnalysisUtils.getLocalOrderParameter}\pysiglinewithargsret{\code{AnalysisUtils.}\bfcode{getLocalOrderParameter}}{\emph{sigma}, \emph{angles}, \emph{r}}{}
Calculate local order parameter.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{sigma} -- numpy array with cell id's

\item {} 
\textbf{angles} -- numpy array with cell angles (radians)

\item {} 
\textbf{r} (\emph{int}) -- radius of neighborhood

\end{itemize}

\item[{Returns}] \leavevmode
local order parameter

\end{description}\end{quote}


\strong{See Also:}


{\hyperref[AnalysisUtils:AnalysisUtils.getDirector]{\code{getDirector()}}}



\end{fulllineitems}

\index{getGlobalOrderParameter() (in module AnalysisUtils)}

\begin{fulllineitems}
\phantomsection\label{AnalysisUtils:AnalysisUtils.getGlobalOrderParameter}\pysiglinewithargsret{\code{AnalysisUtils.}\bfcode{getGlobalOrderParameter}}{\emph{sigma}, \emph{angles}}{}
Calculate global order parameter.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{sigma} -- numpy array with cell id's

\item {} 
\textbf{angles} -- numpy array with cell angles (radians)

\end{itemize}

\item[{Returns}] \leavevmode
global order parameter

\end{description}\end{quote}

\end{fulllineitems}

\index{getRelativeDirField() (in module AnalysisUtils)}

\begin{fulllineitems}
\phantomsection\label{AnalysisUtils:AnalysisUtils.getRelativeDirField}\pysiglinewithargsret{\code{AnalysisUtils.}\bfcode{getRelativeDirField}}{\emph{sigma}, \emph{r}}{}
Calculate field with relative director for each pixel. The relative director is the difference to the angle of the cell at that pixel and the relative director on the pixel. Pixels with high values represent unordered areas, such as branchpoints.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{sigma} -- numpy array with cell id's

\item {} 
\textbf{r} (\emph{int}) -- radius of neighborhood

\end{itemize}

\item[{Returns}] \leavevmode
field with relative director values

\end{description}\end{quote}


\strong{See Also:}


{\hyperref[AnalysisUtils:AnalysisUtils.getDirector]{\code{getDirector()}}}, {\hyperref[AnalysisUtils:AnalysisUtils.getAngleField]{\code{getAngleField()}}}



\end{fulllineitems}



\section{Cell clusters}
\label{AnalysisUtils:cell-clusters}
Clusters of aligned cells are automatically detected using the relative director field, with the following steps:
\begin{enumerate}
\item {} 
Remove all pixels that have a value in the relative director field higher than a given threshold.

\item {} \begin{description}
\item[{Detect blobs in remaining image with a labeling algorith:}] \leavevmode\begin{enumerate}
\item {} 
an opening operation may be performed before labeling.

\item {} 
areas smaller than a given size are ignored;

\end{enumerate}

\end{description}

\item {} \begin{description}
\item[{Map each blob on the CPM grid:}] \leavevmode\begin{enumerate}
\item {} 
at least a given fraction of the cell must be on the labeled area.

\end{enumerate}

\end{description}

\item {} \begin{description}
\item[{Check for cells in multiple clusters:}] \leavevmode\begin{enumerate}
\item {} 
remove cell from all but biggest cluster;

\item {} 
remove cluster if it is empty after (a).

\end{enumerate}

\end{description}

\end{enumerate}
\index{getCellClusters() (in module AnalysisUtils)}

\begin{fulllineitems}
\phantomsection\label{AnalysisUtils:AnalysisUtils.getCellClusters}\pysiglinewithargsret{\code{AnalysisUtils.}\bfcode{getCellClusters}}{\emph{field}, \emph{sigma}, \emph{th=15}, \emph{minlabsize=50}, \emph{opendisk=1}, \emph{mincellsize=0.25}}{}
Get clusters for a single morphology.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{field} -- numpy array with values on which data is seperated

\item {} 
\textbf{cells} -- dict with cell identifiers as keys and \code{ClusterCell} instances as values

\item {} 
\textbf{sigma} -- CPM grid

\item {} 
\textbf{th} (\emph{number}) -- threshold value for step 1

\item {} 
\textbf{minlabsize} (\emph{int}) -- labelled areas smaller than this value are ignored (2b)

\item {} 
\textbf{opendisk} (\emph{int}) -- disk size for opening operation (2a)

\item {} 
\textbf{mincellsize} (\emph{number}) -- minimal fraction of the cell that must be on the labelled area to be added to the cluster

\end{itemize}

\item[{Returns}] \leavevmode
dictionary with cluster id as key and {\hyperref[AnalysisUtils:AnalysisUtils.Cluster]{\code{Cluster}}} instances

\end{description}\end{quote}


\strong{See Also:}


{\hyperref[AnalysisUtils:AnalysisUtils.Cluster]{\code{Cluster}}}



\end{fulllineitems}

\index{Cluster (class in AnalysisUtils)}

\begin{fulllineitems}
\phantomsection\label{AnalysisUtils:AnalysisUtils.Cluster}\pysiglinewithargsret{\strong{class }\code{AnalysisUtils.}\bfcode{Cluster}}{\emph{id}}{}
Container for a cell cluster
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} -- cluster id

\item[{Variables}] \leavevmode
\textbf{cells} -- list of ids of the cells in the clusters

\end{description}\end{quote}
\index{addCell() (AnalysisUtils.Cluster method)}

\begin{fulllineitems}
\phantomsection\label{AnalysisUtils:AnalysisUtils.Cluster.addCell}\pysiglinewithargsret{\bfcode{addCell}}{\emph{cellid}}{}
Add cell to cluster
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{cellid} -- id of cell

\end{description}\end{quote}

\end{fulllineitems}

\index{getClusterSize() (AnalysisUtils.Cluster method)}

\begin{fulllineitems}
\phantomsection\label{AnalysisUtils:AnalysisUtils.Cluster.getClusterSize}\pysiglinewithargsret{\bfcode{getClusterSize}}{}{}
Calculate number of cell in cluster
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
number of cells in cluster

\end{description}\end{quote}

\end{fulllineitems}

\index{removeCell() (AnalysisUtils.Cluster method)}

\begin{fulllineitems}
\phantomsection\label{AnalysisUtils:AnalysisUtils.Cluster.removeCell}\pysiglinewithargsret{\bfcode{removeCell}}{\emph{cellid}}{}
Remove cell from cluster
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{cellid} -- id of cell

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ClusterCellTC (class in AnalysisUtils)}

\begin{fulllineitems}
\phantomsection\label{AnalysisUtils:AnalysisUtils.ClusterCellTC}\pysiglinewithargsret{\strong{class }\code{AnalysisUtils.}\bfcode{ClusterCellTC}}{\emph{id}}{}
A class that holds properties related to a cell at each measured time step. These properties are:
\begin{itemize}
\item {} 
cluster id and size at each time step

\item {} 
long axis at each time step

\item {} 
center of mass at each time step

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} -- cell id

\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{id} -- cell id

\item {} 
\textbf{clusterId} -- list of cluster id's

\item {} 
\textbf{clusterSize} -- list of cluster sizes

\item {} 
\textbf{time} -- list of time steps

\item {} 
\textbf{laxis} -- 2D array with long axes of the cell

\item {} 
\textbf{com} -- 2D array with centers of mass of the cell

\end{itemize}

\end{description}\end{quote}
\index{addTimeStep() (AnalysisUtils.ClusterCellTC method)}

\begin{fulllineitems}
\phantomsection\label{AnalysisUtils:AnalysisUtils.ClusterCellTC.addTimeStep}\pysiglinewithargsret{\bfcode{addTimeStep}}{\emph{t}, \emph{pix}, \emph{cid}, \emph{csz}}{}
Add time step
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{t} (\emph{int}) -- time step

\item {} 
\textbf{pix} -- cell coordinates ({[}x1,...,xn{]},{[}y1,...,yn{]})

\item {} 
\textbf{cid} (\emph{int}) -- cluster id

\item {} 
\textbf{csz} (\emph{int}) -- cluster size

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Cell angles}
\label{AnalysisUtils:cell-angles}
The angle of a cell is calculated from the inertia tensor of a cell. From the intertia tensor we calucate the eigenvalues and eigenvectors; the eigenvector that corresponds with the largest eigenvalue represents the direction of the long axis of a cell. The angle between the long axis and the x-axis is the cell angle.
\index{getCellInertiaTensor() (in module AnalysisUtils)}

\begin{fulllineitems}
\phantomsection\label{AnalysisUtils:AnalysisUtils.getCellInertiaTensor}\pysiglinewithargsret{\code{AnalysisUtils.}\bfcode{getCellInertiaTensor}}{\emph{pix}}{}
Get inertia tensor for a cell
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{pix} -- cell coordinates ({[}x1,...,xn{]},{[}y1,...,yn{]})

\item[{Returns}] \leavevmode
inertia tensor {[}{[}Ixx,Ixy{]},{[}Ixy,Iyy{]}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{getCellOrientation() (in module AnalysisUtils)}

\begin{fulllineitems}
\phantomsection\label{AnalysisUtils:AnalysisUtils.getCellOrientation}\pysiglinewithargsret{\code{AnalysisUtils.}\bfcode{getCellOrientation}}{\emph{pix}}{}
Calculate orientation of a cell. The orientation is the eigenvector corresponding to the largest eigenvalue of the cells' inertia tensor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{pix} -- cell coordinates ({[}x1,...,xn{]},{[}y1,...,yn{]})

\item[{Returns}] \leavevmode
unit vector of the cell orientation

\end{description}\end{quote}


\strong{See Also:}


{\hyperref[AnalysisUtils:AnalysisUtils.getCellInertiaTensor]{\code{getCellInertiaTensor()}}}



\end{fulllineitems}

\index{getCellAngle() (in module AnalysisUtils)}

\begin{fulllineitems}
\phantomsection\label{AnalysisUtils:AnalysisUtils.getCellAngle}\pysiglinewithargsret{\code{AnalysisUtils.}\bfcode{getCellAngle}}{\emph{pix}}{}
Calculate angle of a cell on interval $[0,\pi]$
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{pix} -- cell coordinates ({[}x1,...,xn{]},{[}y1,...,yn{]})

\item[{Returns}] \leavevmode
angle in radians on interval $[0,\pi]$

\end{description}\end{quote}


\strong{See Also:}


{\hyperref[AnalysisUtils:AnalysisUtils.getCellOrientation]{\code{getCellOrientation()}}}



\end{fulllineitems}

\index{getAngleField() (in module AnalysisUtils)}

\begin{fulllineitems}
\phantomsection\label{AnalysisUtils:AnalysisUtils.getAngleField}\pysiglinewithargsret{\code{AnalysisUtils.}\bfcode{getAngleField}}{\emph{sigma}}{}
Get field with the cell angles
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{sigma} -- numpy array with cell id's

\item[{Returns}] \leavevmode
numpy array with cell angles in radians

\end{description}\end{quote}

\end{fulllineitems}



\section{Mean squared displacement}
\label{AnalysisUtils:mean-squared-displacement}
The \href{http://en.wikipedia.org/wiki/Mean\_squared\_displacement}{mean squared displacement} describes the displacement of a cell over time with respect to the initial position : $MSD = \left \langle (x(t) - x(0))^2 \right \rangle\;$. In a similar manner the mean squared angular displacement can be calculated : $MSD = \left \langle (\theta(t) - \theta(0))^2 \right \rangle\;$
\index{calcMSDTransForCellTC() (in module AnalysisUtils)}

\begin{fulllineitems}
\phantomsection\label{AnalysisUtils:AnalysisUtils.calcMSDTransForCellTC}\pysiglinewithargsret{\code{AnalysisUtils.}\bfcode{calcMSDTransForCellTC}}{\emph{com}}{}
Calculate the translational MSD for a single object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{com} -- list of centers of mass at each time step

\item[{Returns}] \leavevmode
list with MSD for each time step

\end{description}\end{quote}

\end{fulllineitems}

\index{calcMSDRotForCellTC() (in module AnalysisUtils)}

\begin{fulllineitems}
\phantomsection\label{AnalysisUtils:AnalysisUtils.calcMSDRotForCellTC}\pysiglinewithargsret{\code{AnalysisUtils.}\bfcode{calcMSDRotForCellTC}}{\emph{vecset}}{}
Calculate the rotational MSD for a single object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{vecset} -- list of orientation vectors for each time step

\item[{Returns}] \leavevmode
list with MSD for each time step

\end{description}\end{quote}

\end{fulllineitems}



\chapter{ImageUtils}
\label{ImageUtils:imageutils}\label{ImageUtils::doc}\index{makeImage() (in module ImageUtils)}

\begin{fulllineitems}
\phantomsection\label{ImageUtils:ImageUtils.makeImage}\pysiglinewithargsret{\code{ImageUtils.}\bfcode{makeImage}}{\emph{id}, \emph{inpath}, \emph{t}, \emph{colormap}, \emph{timestamp=False}, \emph{label=False}, \emph{scale=1}, \emph{bc=None}, \emph{fontsize=6}, \emph{border=True}, \emph{gzipped=True}, \emph{fieldname=None}, \emph{fontpath='/usr/share/fonts/msttcore/'}}{}
Draw morphology for one timestep
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{id} (\emph{str}) -- simulation identifier

\item {} 
\textbf{inpath} (\emph{str}) -- path containing data files

\item {} 
\textbf{t} (\emph{int}) -- time step

\item {} 
\textbf{outpath} (\emph{str}) -- path to save images to

\item {} 
\textbf{colormap} -- dictionary with cell types as keys and colors (r,g,b) as values

\item {} 
\textbf{timestamp} (\emph{bool}) -- add time stamp to the image

\item {} 
\textbf{label} (\emph{bool}) -- add id as label to the image

\item {} 
\textbf{scale} (\emph{number}) -- scaling of the image

\item {} 
\textbf{bc} -- color of cell boundaries (r,g,b)

\item {} 
\textbf{fontsize} (\emph{int}) -- size of the fonts used for label and time stamp; font size will be multiplied by scale.

\item {} 
\textbf{border} (\emph{bool}) -- cut of border pixels

\item {} 
\textbf{gzipped} (\emph{bool}) -- data is gzipped

\item {} 
\textbf{fieldname} (\emph{str}) -- name of chemical field

\item {} 
\textbf{fontpath} (\emph{str}) -- path to freetype fonts

\end{itemize}

\item[{Returns}] \leavevmode
image object

\end{description}\end{quote}


\strong{See Also:}


\code{drawCells()}, \code{addTimeStamp()}, \code{addLabel()}    



\end{fulllineitems}

\index{drawRelDirField() (in module ImageUtils)}

\begin{fulllineitems}
\phantomsection\label{ImageUtils:ImageUtils.drawRelDirField}\pysiglinewithargsret{\code{ImageUtils.}\bfcode{drawRelDirField}}{\emph{field}, \emph{sigma}, \emph{scale=1}}{}
Draw gray-scale image of a field representing the relative director
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{field} -- numpy array with relative director

\item {} 
\textbf{sigma} -- numpy array with cell id's

\item {} 
\textbf{scale} (\emph{number}) -- scaling factor

\end{itemize}

\item[{Returns}] \leavevmode
image object

\end{description}\end{quote}

\end{fulllineitems}

\index{stackImages() (in module ImageUtils)}

\begin{fulllineitems}
\phantomsection\label{ImageUtils:ImageUtils.stackImages}\pysiglinewithargsret{\code{ImageUtils.}\bfcode{stackImages}}{\emph{images}, \emph{geometry}, \emph{filename}, \emph{label=False}, \emph{title=None}, \emph{fontsize=20}, \emph{border=False}, \emph{scale=1}, \emph{fontpath='/usr/share/fonts/msttcore/'}}{}
Stack a set of images together in one image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{images} -- dictionary with labels as keys and image filenames as values

\item {} 
\textbf{geometry} -- number of rows and columns (x,y)

\item {} 
\textbf{filename} (\emph{str}) -- target of the stacked image

\item {} 
\textbf{label} (\emph{bool}) -- add labels to the subimages

\item {} 
\textbf{title} (\emph{str}) -- overall title for image

\item {} 
\textbf{fontsize} (\emph{int}) -- font size (only for freetype fonts)

\item {} 
\textbf{border} (\emph{bool}) -- add border to subimages

\item {} 
\textbf{scale} (\emph{number}) -- scaling factor of the created picture

\item {} 
\textbf{fontpath} (\emph{str}) -- path to freetype fonts

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{morphImages() (in module ImageUtils)}

\begin{fulllineitems}
\phantomsection\label{ImageUtils:ImageUtils.morphImages}\pysiglinewithargsret{\code{ImageUtils.}\bfcode{morphImages}}{\emph{images}, \emph{filename}, \emph{xlabel=None}, \emph{ylabel=None}, \emph{xtics=None}, \emph{ytics=None}, \emph{fontsize=20}, \emph{scale=1}, \emph{border=False}, \emph{title=None}, \emph{bcolor=(255}, \emph{255}, \emph{255)}, \emph{fcolor=(0}, \emph{0}, \emph{0)}, \emph{fontpath='/usr/share/fonts/msttcore/'}, \emph{delta=0}}{}
Stack a set of images together in one morphospace.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{images} -- 2D array with image filenames

\item {} 
\textbf{filename} (\emph{str}) -- target of the stacked image

\item {} 
\textbf{xlabel} (\emph{str}) -- label to be plotted on x-axis

\item {} 
\textbf{ylabel} -- label to be plotted on y-axis

\item {} 
\textbf{ylabel} -- str

\item {} 
\textbf{xtics} -- list of labels on x-axis

\item {} 
\textbf{ytics} -- list of labels on y-axis

\item {} 
\textbf{fontsize} (\emph{int}) -- fontsize for labels and title

\item {} 
\textbf{scale} (\emph{number}) -- scaling factor of the created picture

\item {} 
\textbf{border} (\emph{bool}) -- add border to subimages

\item {} 
\textbf{title} (\emph{str}) -- overall title for image

\item {} 
\textbf{bcolor} -- background color (r,g,b)

\item {} 
\textbf{fcolor} -- font color (r,g,b)

\item {} 
\textbf{fontpath} (\emph{str}) -- path to freetype fonts

\item {} 
\textbf{delta} (\emph{number}) -- extra space between images

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Readers}
\label{Readers::doc}\label{Readers:readers}
Collection of functions to read simulation data and other files needed by MIMBSimUtils.
\phantomsection\label{Readers:module-Readers}\index{Readers (module)}\index{readChemField() (in module Readers)}

\begin{fulllineitems}
\phantomsection\label{Readers:Readers.readChemField}\pysiglinewithargsret{\code{Readers.}\bfcode{readChemField}}{\emph{simid}, \emph{t}, \emph{indir}, \emph{fieldname}, \emph{gzipped=True}, \emph{border=True}}{}
Read chemical field from file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{simid} (\emph{str}) -- simulation identifier

\item {} 
\textbf{t} (\emph{int}) -- time step

\item {} 
\textbf{indir} (\emph{str}) -- path to data files

\item {} 
\textbf{fieldname} (\emph{str}) -- name of the chemical field

\item {} 
\textbf{gzipped} (\emph{bool}) -- data is gzipped (gzipped data is expected to be in indir/simid/)

\item {} 
\textbf{border} (\emph{bool}) -- cut of border pixels

\end{itemize}

\item[{Returns}] \leavevmode
numpy array with the levels of the chemical field at each position

\end{description}\end{quote}

\end{fulllineitems}

\index{readColorMap() (in module Readers)}

\begin{fulllineitems}
\phantomsection\label{Readers:Readers.readColorMap}\pysiglinewithargsret{\code{Readers.}\bfcode{readColorMap}}{\emph{filename}}{}
Read colormap from a file, formatted like: celltype r g b
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{filename} (\emph{str}) -- file with the colormap

\item[{Returns}] \leavevmode
dictionary with cell type as keys and colors (r,g,b) as values.

\end{description}\end{quote}

\end{fulllineitems}

\index{readSigma() (in module Readers)}

\begin{fulllineitems}
\phantomsection\label{Readers:Readers.readSigma}\pysiglinewithargsret{\code{Readers.}\bfcode{readSigma}}{\emph{simid}, \emph{t}, \emph{indir}, \emph{gzipped=True}, \emph{border=True}}{}
Read cell field (sigma) from file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{simid} (\emph{str}) -- simulation identifier

\item {} 
\textbf{t} (\emph{int}) -- time step

\item {} 
\textbf{indir} (\emph{str}) -- path to data files

\item {} 
\textbf{gzipped} (\emph{bool}) -- data is gzipped (gzipped data is expected to be in indir/simid/)

\item {} 
\textbf{border} (\emph{bool}) -- cut of border pixels

\end{itemize}

\item[{Returns}] \leavevmode
numpy array with cell id's

\end{description}\end{quote}

\end{fulllineitems}

\index{readTau() (in module Readers)}

\begin{fulllineitems}
\phantomsection\label{Readers:Readers.readTau}\pysiglinewithargsret{\code{Readers.}\bfcode{readTau}}{\emph{simid}, \emph{t}, \emph{indir}, \emph{gzipped=True}, \emph{border=True}}{}
Read type field (tau) from file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{simid} (\emph{str}) -- simulation identifier

\item {} 
\textbf{t} (\emph{int}) -- time step

\item {} 
\textbf{indir} (\emph{str}) -- path to data files

\item {} 
\textbf{gzipped} (\emph{bool}) -- data is gzipped (gzipped data is expected to be in indir/simid/)

\item {} 
\textbf{border} (\emph{bool}) -- cut of border pixels

\end{itemize}

\item[{Returns}] \leavevmode
numpy array with cell types

\end{description}\end{quote}

\end{fulllineitems}



\chapter{CC3DPipeline}
\label{CC3DPipeline:cc3dpipeline}\label{CC3DPipeline::doc}

\section{Pre-Processing}
\label{CC3DPipeline:pre-processing}\index{createPBSScripts() (in module CC3DPipeline)}

\begin{fulllineitems}
\phantomsection\label{CC3DPipeline:CC3DPipeline.createPBSScripts}\pysiglinewithargsret{\code{CC3DPipeline.}\bfcode{createPBSScripts}}{\emph{runid}, \emph{joblist}, \emph{command}, \emph{time}, \emph{ncores=8}, \emph{ppn=8}, \emph{path='clusterScripts/'}}{}
Create a set of PBS scripts to run a simulation on a cluster. Each script starts with something like:
\begin{quote}

\#PBS -S /bin/bash
\#PBS -lnodes=1:cores12:ppn=11
\#PBS -lwalltime=12:00:00
\end{quote}

If these commands are not correct or complete for the cluster you use, edit {\hyperref[CC3DPipeline:CC3DPipeline.createPBS]{\code{createPBS()}}}.

For each job in joblist a single line command is added to the script:
\begin{quote}

python command jobid \textgreater{} log/jobid.out 2\textgreater{} log/jobid.err \&
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{runid} (\emph{str}) -- identifier for the scripts

\item {} 
\textbf{joblist} -- list of job identifiers

\item {} 
\textbf{command} (\emph{str}) -- command that runs the simulation

\item {} 
\textbf{time} (\emph{str}) -- requested walltime on the cluster (hh:mm:ss)

\item {} 
\textbf{ncores} (\emph{int}) -- numbor of cores in the requested node

\item {} 
\textbf{ppn} (\emph{int}) -- number of processers per node that will be used

\item {} 
\textbf{path} (\emph{str}) -- location where pbs scripts are saved

\end{itemize}

\end{description}\end{quote}


\strong{See Also:}


{\hyperref[CC3DPipeline:CC3DPipeline.createPBS]{\code{createPBS()}}}, {\hyperref[CC3DPipeline:CC3DPipeline.addCommandToPBS]{\code{addCommandToPBS()}}}, {\hyperref[CC3DPipeline:CC3DPipeline.finishPBS]{\code{finishPBS()}}}        



\end{fulllineitems}

\index{createPBS() (in module CC3DPipeline)}

\begin{fulllineitems}
\phantomsection\label{CC3DPipeline:CC3DPipeline.createPBS}\pysiglinewithargsret{\code{CC3DPipeline.}\bfcode{createPBS}}{\emph{filename}, \emph{time}, \emph{ncores=None}, \emph{ppn=None}}{}
Create a new pbs script and add initial commands and settings.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) -- filename of the new pbs script

\item {} 
\textbf{time} (\emph{str}) -- requested walltime on the cluster (hh:mm:ss)

\item {} 
\textbf{ncores} (\emph{int}) -- numbor of cores in the requested node

\item {} 
\textbf{ppn} (\emph{int}) -- number of processers per node that will be used

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{addCommandToPBS() (in module CC3DPipeline)}

\begin{fulllineitems}
\phantomsection\label{CC3DPipeline:CC3DPipeline.addCommandToPBS}\pysiglinewithargsret{\code{CC3DPipeline.}\bfcode{addCommandToPBS}}{\emph{filename}, \emph{command}, \emph{log}}{}
Add single line command to existing PBS script:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) -- filename of the new pbs script

\item {} 
\textbf{command} (\emph{str}) -- command that runs the simulation

\item {} 
\textbf{log} (\emph{str}) -- name (with path) of the log files (without extension)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{finishPBS() (in module CC3DPipeline)}

\begin{fulllineitems}
\phantomsection\label{CC3DPipeline:CC3DPipeline.finishPBS}\pysiglinewithargsret{\code{CC3DPipeline.}\bfcode{finishPBS}}{\emph{filename}}{}
Finish pbs file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{filename} (\emph{str}) -- filename of the new pbs script

\end{description}\end{quote}

\end{fulllineitems}



\section{Post-Processing}
\label{CC3DPipeline:post-processing}\index{makeImages() (in module CC3DPipeline)}

\begin{fulllineitems}
\phantomsection\label{CC3DPipeline:CC3DPipeline.makeImages}\pysiglinewithargsret{\code{CC3DPipeline.}\bfcode{makeImages}}{\emph{id}, \emph{trange}, \emph{inpath}, \emph{outpath}, \emph{cm='default.ctb'}, \emph{gzipped=False}, \emph{timestamp=False}, \emph{label=False}, \emph{scale=1}, \emph{bc=None}, \emph{fontsize=6}, \emph{fieldname=None}, \emph{border=True}}{}
Make images for a single simulation simulation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{id} (\emph{str}) -- simulation identifier

\item {} 
\textbf{trange} -- list of time steps for which images are created

\item {} 
\textbf{inpath} (\emph{str}) -- path to data

\item {} 
\textbf{outpath} (\emph{str}) -- path to save images to

\item {} 
\textbf{cm} (\emph{str}) -- file containing the colormap

\item {} 
\textbf{gzipped} (\emph{bool}) -- data is gzipped

\item {} 
\textbf{timestamp} (\emph{bool}) -- add time stamp to the image

\item {} 
\textbf{label} (\emph{bool}) -- add id as label to the image

\item {} 
\textbf{scale} (\emph{number}) -- scaling of the image

\item {} 
\textbf{bc} -- color of cell boundaries (r,g,b)

\item {} 
\textbf{fontsize} (\emph{int}) -- size of the fonts used for label and time stamp; font size will be multiplied by scale.

\item {} 
\textbf{fieldname} (\emph{str}) -- name of chemical field

\item {} 
\textbf{border} (\emph{bool}) -- cut of border pixels

\end{itemize}

\end{description}\end{quote}


\strong{See Also:}


{\hyperref[ImageUtils:ImageUtils.makeImage]{\code{makeImage()}}}



\end{fulllineitems}

\index{getCompactnessForSim() (in module CC3DPipeline)}

\begin{fulllineitems}
\phantomsection\label{CC3DPipeline:CC3DPipeline.getCompactnessForSim}\pysiglinewithargsret{\code{CC3DPipeline.}\bfcode{getCompactnessForSim}}{\emph{id}, \emph{trange}, \emph{inpath}, \emph{gzipped=False}, \emph{border=True}, \emph{outpath=None}}{}
Calculate compactness for one simulation, the compactness is in a file: outpath/id\_compactness.data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{id} (\emph{str}) -- simulation identifier

\item {} 
\textbf{trange} -- list of time steps for which the compactness is calculated

\item {} 
\textbf{inpath} (\emph{str}) -- path to data

\item {} 
\textbf{gzipped} (\emph{bool}) -- if True, data is expected to be gzipped, and stored in inpath/id/, and the output file will be gzipped and stored in outpath/id/

\item {} 
\textbf{border} (\emph{bool}) -- remove border pixels from data

\item {} 
\textbf{outpath} (\emph{str}) -- path where order parameter data will be saved, if omitted outpath = inpath

\end{itemize}

\end{description}\end{quote}


\strong{See Also:}


{\hyperref[AnalysisUtils:AnalysisUtils.getCompactness]{\code{getCompactness()}}}



\end{fulllineitems}

\index{getOrderParameterForSim() (in module CC3DPipeline)}

\begin{fulllineitems}
\phantomsection\label{CC3DPipeline:CC3DPipeline.getOrderParameterForSim}\pysiglinewithargsret{\code{CC3DPipeline.}\bfcode{getOrderParameterForSim}}{\emph{id}, \emph{trange}, \emph{inpath}, \emph{radii}, \emph{gzipped=False}, \emph{border=True}, \emph{outpath=None}}{}
Calculate orderparameters for one simulation. All order parameters are collected and saved in a file outpath/id\_orderparameter.data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{id} (\emph{str}) -- simulation identifier

\item {} 
\textbf{trange} -- list of time steps for which the order parameter is calculated

\item {} 
\textbf{inpath} (\emph{str}) -- path to data

\item {} 
\textbf{radii} -- list of radii for wich the order parameter is calculates

\item {} 
\textbf{gzipped} (\emph{bool}) -- if True, data is expected to be gzipped, and stored in inpath/id/, and the output file will be gzipped and stored in outpath/id/

\item {} 
\textbf{border} (\emph{bool}) -- remove border pixels from data

\item {} 
\textbf{outpath} (\emph{str}) -- path where order parameter data will be saved, if omitted outpath = inpath

\end{itemize}

\end{description}\end{quote}


\strong{See Also:}


{\hyperref[AnalysisUtils:AnalysisUtils.getOrderParameter]{\code{getOrderParameter()}}}



\end{fulllineitems}

\index{getClustersForSim() (in module CC3DPipeline)}

\begin{fulllineitems}
\phantomsection\label{CC3DPipeline:CC3DPipeline.getClustersForSim}\pysiglinewithargsret{\code{CC3DPipeline.}\bfcode{getClustersForSim}}{\emph{id}, \emph{trange}, \emph{inpath}, \emph{r}, \emph{th}, \emph{minlabsize}, \emph{opendisk}, \emph{mincellsize}, \emph{gzipped=False}, \emph{border=False}, \emph{outpath=None}}{}
Calculate clusters and mean squared displacement and rotation for each cell in a simulation. For more details on clustering see the documentation of {\hyperref[AnalysisUtils:AnalysisUtils.getCellClusters]{\code{getCellClusters()}}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{id} (\emph{str}) -- simulation identifier

\item {} 
\textbf{trange} -- list of time steps for which the clusters are calculated

\item {} 
\textbf{inpath} (\emph{str}) -- path to data

\item {} 
\textbf{r} (\emph{number}) -- radius for relative director field

\item {} 
\textbf{th} (\emph{number}) -- threshold value for step 1

\item {} 
\textbf{minlabsize} -- labelled areas smaller than this value are ignored (2b)

\item {} 
\textbf{opendisk} (\emph{int}) -- disk size for opening operation (2a)

\item {} 
\textbf{mincellsize} (\emph{int}) -- minimal fraction of the cell that must be on the labelled area to be added to the  cluster

\item {} 
\textbf{gzipped} (\emph{bool}) -- if True, data is expected to be gzipped, and stored in inpath/id/, and the output file will be gzipped and stored in outpath/id/

\item {} 
\textbf{border} (\emph{bool}) -- remove border pixels from data

\item {} 
\textbf{outpath} (\emph{str}) -- path where order parameter data will be saved, if omitted outpath = inpath

\end{itemize}

\end{description}\end{quote}


\strong{See Also:}


{\hyperref[AnalysisUtils:AnalysisUtils.getCellClusters]{\code{getCellClusters()}}}, {\hyperref[AnalysisUtils:AnalysisUtils.getRelativeDirField]{\code{getRelativeDirField()}}}, {\hyperref[AnalysisUtils:AnalysisUtils.calcMSDTransForCellTC]{\code{calcMSDTransForCellTC()}}}, {\hyperref[AnalysisUtils:AnalysisUtils.calcMSDRotForCellTC]{\code{calcMSDRotForCellTC()}}}, {\hyperref[AnalysisUtils:AnalysisUtils.ClusterCellTC]{\code{ClusterCellTC}}}



\end{fulllineitems}



\chapter{Experiment}
\label{Experiment:experiment}\label{Experiment::doc}\index{Experiment (class in Experiment)}

\begin{fulllineitems}
\phantomsection\label{Experiment:Experiment.Experiment}\pysiglinewithargsret{\strong{class }\code{Experiment.}\bfcode{Experiment}}{\emph{templatefile}}{}
The class Experiments holds the data for a CC3D experiment as an xml object. This objects is created from a template xml file. Elements that are already present in the template can be changed or removed and new elements can be added. When the xml is written to file all unchanged content of the template, including commented xml, is written to the new file.
\index{addStatistics() (Experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{Experiment:Experiment.Experiment.addStatistics}\pysiglinewithargsret{\bfcode{addStatistics}}{\emph{freq}, \emph{basename}}{}
Edit statistics save options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{freq} -- save frequency

\item {} 
\textbf{basename} -- basename for files (full path)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{deletePlugin() (Experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{Experiment:Experiment.Experiment.deletePlugin}\pysiglinewithargsret{\bfcode{deletePlugin}}{\emph{name}}{}
Delete plugin
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{name} -- plugin name

\end{description}\end{quote}

\end{fulllineitems}

\index{deletePottsProperty() (Experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{Experiment:Experiment.Experiment.deletePottsProperty}\pysiglinewithargsret{\bfcode{deletePottsProperty}}{\emph{tagname}}{}
Remove element from the Potts element
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{tagname} -- name of element

\end{description}\end{quote}

\end{fulllineitems}

\index{deleteSteppable() (Experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{Experiment:Experiment.Experiment.deleteSteppable}\pysiglinewithargsret{\bfcode{deleteSteppable}}{\emph{type}}{}
Delete steppable
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{type} -- steppable type

\end{description}\end{quote}

\end{fulllineitems}

\index{setChemotaxis() (Experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{Experiment:Experiment.Experiment.setChemotaxis}\pysiglinewithargsret{\bfcode{setChemotaxis}}{\emph{celltype}, \emph{towards}, \emph{lam}}{}
Set chemotaxis for cell type
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{celltype} -- name of the cell type

\item {} 
\textbf{towards} -- cell type towards chemotaxis occurs

\item {} 
\textbf{lam} -- chemotactic strength

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{setContact() (Experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{Experiment:Experiment.Experiment.setContact}\pysiglinewithargsret{\bfcode{setContact}}{\emph{\_type1}, \emph{\_type2}, \emph{J}}{}
Edit contact energy
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{type1} -- name of the first cell type

\item {} 
\textbf{type2} -- name of the second cell type

\item {} 
\textbf{J} -- contact energy between type1 and type2

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{setDebugFrequencyInMeta() (Experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{Experiment:Experiment.Experiment.setDebugFrequencyInMeta}\pysiglinewithargsret{\bfcode{setDebugFrequencyInMeta}}{\emph{freq}}{}
Set debug frequency
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{frequency} -- frequency

\end{description}\end{quote}

\end{fulllineitems}

\index{setGenericPlugin() (Experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{Experiment:Experiment.Experiment.setGenericPlugin}\pysiglinewithargsret{\bfcode{setGenericPlugin}}{\emph{name}, \emph{elements=}\optional{}}{}
Set generic plugin. If the plugin is already in the template, it is updated. If not, the plugin is added to the model. This function does not support multi-level xml elements.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{name} -- plugin name

\item {} 
\textbf{elements} -- list of elements described by a dictionary: \{`name':name,'value':val,'attributes':\{\}\}

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{setGenericSteppable() (Experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{Experiment:Experiment.Experiment.setGenericSteppable}\pysiglinewithargsret{\bfcode{setGenericSteppable}}{\emph{type}, \emph{freq=None}, \emph{elements=}\optional{}}{}
Set generic steppable. If the steppable is already in the template, it is updated. If not, the plugin is added to the model. This function does not support multi-level xml elements.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{type} -- steppable type

\item {} 
\textbf{freq} -- frequency

\item {} 
\textbf{elements} -- list of elements described by a dictionary with keys name, value and attributes

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{setMCS() (Experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{Experiment:Experiment.Experiment.setMCS}\pysiglinewithargsret{\bfcode{setMCS}}{\emph{mcs}}{}
Set number of Monte Carlo steps
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{mcs} -- number of MCS (note that mcs+1 appears in the xml)

\end{description}\end{quote}

\end{fulllineitems}

\index{setMotility() (Experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{Experiment:Experiment.Experiment.setMotility}\pysiglinewithargsret{\bfcode{setMotility}}{\emph{celltype}, \emph{T}}{}
Edit motility parameters per cell type
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{celltype} -- name of the cell type

\item {} 
\textbf{T} -- motility

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{setMultiCore() (Experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{Experiment:Experiment.Experiment.setMultiCore}\pysiglinewithargsret{\bfcode{setMultiCore}}{\emph{threads=1}, \emph{cores=1}}{}
Set number of threads and cores for a simulation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{threads} -- number of threads per core

\item {} 
\textbf{cores} -- number of cores

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{setPottsProperty() (Experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{Experiment:Experiment.Experiment.setPottsProperty}\pysiglinewithargsret{\bfcode{setPottsProperty}}{\emph{tagname}, \emph{attributes=\{\}}, \emph{value=None}}{}
General function to set a parameter in the Potts element
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{tagname} -- name of the element

\item {} 
\textbf{attributes} -- dictionary with attribute names as key and attribute values as values.

\item {} 
\textbf{value} -- element value

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{setSecretion() (Experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{Experiment:Experiment.Experiment.setSecretion}\pysiglinewithargsret{\bfcode{setSecretion}}{\emph{celltype}, \emph{s}, \emph{solver='FastDiffusionSolver2DFE'}}{}
Set secretion coefficient for specific cell type
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{celltype} -- name of the cell type

\item {} 
\textbf{s} -- secretion coefficient

\item {} 
\textbf{solver} -- solver name

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{setSeed() (Experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{Experiment:Experiment.Experiment.setSeed}\pysiglinewithargsret{\bfcode{setSeed}}{\emph{seed}}{}
Set simulation seed
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{seed} -- random seed

\end{description}\end{quote}

\end{fulllineitems}

\index{setTemp() (Experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{Experiment:Experiment.Experiment.setTemp}\pysiglinewithargsret{\bfcode{setTemp}}{\emph{T}}{}
Set temperature tag
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{T} -- temperature

\end{description}\end{quote}

\end{fulllineitems}

\index{setVolume() (Experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{Experiment:Experiment.Experiment.setVolume}\pysiglinewithargsret{\bfcode{setVolume}}{\emph{celltype}, \emph{vol}, \emph{lam}}{}
Set volume per cell type
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{celltype} -- cell type name

\item {} 
\textbf{vol} -- target volume

\item {} 
\textbf{lam} -- lambda volume

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{write() (Experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{Experiment:Experiment.Experiment.write}\pysiglinewithargsret{\bfcode{write}}{\emph{filename}}{}
Save xml to file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{filename} -- filename of new xml

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{CC3DSimUtils:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{r}
\item {\texttt{Readers}}, \pageref{Readers:module-Readers}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
