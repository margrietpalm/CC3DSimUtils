
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>AnalysisUtils &mdash; MIMB SimUtils 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="MIMB SimUtils 1.0 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../MIMBSimUtils.html">MIMB SimUtils 1.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for AnalysisUtils</h1><div class="highlight"><pre>
<span class="k">def</span> <span class="nf">getCellAngle</span><span class="p">(</span><span class="n">pix</span><span class="p">):</span>
<div class="viewcode-block" id="getCellAngle"><a class="viewcode-back" href="../AnalysisUtils.html#AnalysisUtils.getCellAngle">[docs]</a>    <span class="sd">&quot;&quot;&quot; Calculate angle of a cell on interval :math:`[0,\pi]`</span>
<span class="sd">    </span>
<span class="sd">    :param pix: cell coordinates ([x1,...,xn],[y1,...,yn])</span>
<span class="sd">    :return: angle in radians on interval :math:`[0,\pi]`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">getCellOrientation</span><span class="p">(</span><span class="n">pix</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">a</span>

<span class="k">def</span> <span class="nf">getAngleField</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span></div>
<div class="viewcode-block" id="getAngleField"><a class="viewcode-back" href="../AnalysisUtils.html#AnalysisUtils.getAngleField">[docs]</a>    <span class="sd">&quot;&quot;&quot; Get field with the cell angles </span>
<span class="sd">    </span>
<span class="sd">    :param sigma: numpy array with cell id&#39;s</span>
<span class="sd">    :return: numpy array with cell angles in radians</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>    
    <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">angles</span><span class="p">[</span><span class="n">sigma</span><span class="o">==</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">getCellAngle</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sigma</span><span class="o">==</span><span class="nb">id</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">angles</span>
    
<span class="k">def</span> <span class="nf">getOrderParameterFromGrid</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">angles</span><span class="p">,</span><span class="n">r</span><span class="p">):</span></div>
<div class="viewcode-block" id="getOrderParameterFromGrid"><a class="viewcode-back" href="../AnalysisUtils.html#AnalysisUtils.getOrderParameterFromGrid">[docs]</a>    <span class="sd">&quot;&quot;&quot; Calculate order parameter for a morphology using the cpm grid data. Based on the given radius the order parameters is either calculated locally :func:`~OpenSimUtils.AnalysisUtils.getLocalOrderParameter` or globally :func:`~OpenSimUtils.AnalysisUtils.getGlobalOrderParameter`.</span>
<span class="sd">    </span>
<span class="sd">    :param sigma: numpy array with cell id&#39;s</span>
<span class="sd">    :param angles: numpy array with cell angles (radians)</span>
<span class="sd">    :param r: radius of neighborhood    </span>
<span class="sd">    :type r: int</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~OpenSimUtils.AnalysisUtils.getLocalOrderParameterFromGrid`, :func:`~OpenSimUtils.AnalysisUtils.getGlobalOrderParameterFromGrid`</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nx</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">ny</span><span class="o">**</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">getLocalOrderParameterFromGrid</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">angles</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">getGlobalOrderParameterFromGrid</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">angles</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">getLocalOrderParameterFromGrid</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">angles</span><span class="p">,</span><span class="n">r</span><span class="p">):</span></div>
<div class="viewcode-block" id="getLocalOrderParameterFromGrid"><a class="viewcode-back" href="../AnalysisUtils.html#AnalysisUtils.getLocalOrderParameterFromGrid">[docs]</a>    <span class="sd">&quot;&quot;&quot; Calculate local order parameter.</span>
<span class="sd">    </span>
<span class="sd">    :param sigma: numpy array with cell id&#39;s</span>
<span class="sd">    :param angles: numpy array with cell angles (radians)</span>
<span class="sd">    :param r: radius of neighborhood    </span>
<span class="sd">    :type r: int   </span>
<span class="sd">    :return: local order parameter</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~OpenSimUtils.AnalysisUtils.getDirector`</span>
<span class="sd">    &quot;&quot;&quot;</span>     
    <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sigma</span><span class="o">==</span><span class="nb">id</span><span class="p">)][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">getDirector</span><span class="p">(</span><span class="n">getCoM</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sigma</span><span class="o">==</span><span class="nb">id</span><span class="p">)),</span><span class="n">r</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">angles</span><span class="p">)</span>        
        <span class="n">dA</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">A</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">A</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">90</span> <span class="k">else</span> <span class="mi">180</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">A</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">dA</span><span class="p">)</span><span class="o">/</span><span class="mf">360.0</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">/</span><span class="n">n</span>

<span class="k">def</span> <span class="nf">getGlobalOrderParameterFromGrid</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">angles</span><span class="p">):</span></div>
<div class="viewcode-block" id="getGlobalOrderParameterFromGrid"><a class="viewcode-back" href="../AnalysisUtils.html#AnalysisUtils.getGlobalOrderParameterFromGrid">[docs]</a>    <span class="sd">&quot;&quot;&quot; Calculate global order parameter.</span>
<span class="sd">    </span>
<span class="sd">    :param sigma: numpy array with cell id&#39;s</span>
<span class="sd">    :param angles: numpy array with cell angles (radians)</span>
<span class="sd">    :return: global order parameter    </span>
<span class="sd">    &quot;&quot;&quot;</span>      
    <span class="n">a</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sigma</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)]</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">dA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">A</span><span class="p">)</span>
    <span class="n">dA</span><span class="p">[</span><span class="n">dA</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dA</span><span class="p">[</span><span class="n">dA</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">]</span><span class="o">-</span><span class="mi">180</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">dA</span><span class="p">)</span><span class="o">/</span><span class="mf">360.0</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">getDirector</span><span class="p">(</span><span class="n">com</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">angles</span><span class="p">):</span></div>
<div class="viewcode-block" id="getDirector"><a class="viewcode-back" href="../AnalysisUtils.html#AnalysisUtils.getDirector">[docs]</a>    <span class="sd">&quot;&quot;&quot; Find the director of the center of mass of a cell. </span>
<span class="sd">        </span>
<span class="sd">    :param com: center of mass of the cell (x,y)</span>
<span class="sd">    :param r: radius of neighborhood</span>
<span class="sd">    :type r: number</span>
<span class="sd">    :param sigma: numpy array with cell id&#39;s</span>
<span class="sd">    :param angles: numpy array with cell angles (radians)</span>
<span class="sd">    :return: director (radians)    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Because we only need the pixels within a radius r from com, we create new</span>
    <span class="c"># array sigma and angles that only contain pixels within this range.</span>
    <span class="n">xmin</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">))</span>
    <span class="n">xmax</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">r</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">r</span><span class="p">))</span>
    <span class="n">ymin</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">))</span>
    <span class="n">ymax</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">r</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">r</span><span class="p">))</span>        
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">[</span><span class="n">xmin</span><span class="p">:</span><span class="n">xmax</span><span class="p">,</span><span class="n">ymin</span><span class="p">:</span><span class="n">ymax</span><span class="p">]</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="n">xmin</span><span class="p">:</span><span class="n">xmax</span><span class="p">,</span><span class="n">ymin</span><span class="p">:</span><span class="n">ymax</span><span class="p">]</span>
    <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">xmin</span><span class="p">:</span><span class="n">xmax</span><span class="p">,</span><span class="n">ymin</span><span class="p">:</span><span class="n">ymax</span><span class="p">]</span>
    <span class="c"># calculate distances between all pixels and com</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">))</span>
    <span class="c"># find all angles at pixels within radius r and sigma &gt; 0</span>
    <span class="n">sa</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">[</span><span class="n">d</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="n">d</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">]</span>
    <span class="n">an</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">sa</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">an</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">an</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">an</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">an</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">getRelativeDirField</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">r</span><span class="p">):</span></div>
<div class="viewcode-block" id="getRelativeDirField"><a class="viewcode-back" href="../AnalysisUtils.html#AnalysisUtils.getRelativeDirField">[docs]</a>    <span class="sd">&quot;&quot;&quot; Calculate field with relative director for each pixel. The relative director is the difference to the angle of the cell at that pixel and the relative director on the pixel. Pixels with high values represent unordered areas, such as branchpoints.</span>
<span class="sd">    </span>
<span class="sd">    :param sigma: numpy array with cell id&#39;s</span>
<span class="sd">    :param r: radius of neighborhood    </span>
<span class="sd">    :type r: int   </span>
<span class="sd">    :return: field with relative director values</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~OpenSimUtils.AnalysisUtils.getDirector`, :func:`~OpenSimUtils.AnalysisUtils.getAngleField`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">getAngleField</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>    
    <span class="nb">dir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>    
    <span class="c"># calculate director at every pixel</span>
    <span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span>    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sigma</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">dir</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">getDirector</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="n">r</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">angles</span><span class="p">,</span><span class="n">weighted</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="c"># calcuate local difference between director and cell angles</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
    <span class="n">field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="nb">dir</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>
    <span class="n">field</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">field</span><span class="o">&gt;</span><span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">field</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">field</span><span class="o">&gt;</span><span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">field</span>
    
<span class="k">def</span> <span class="nf">realconvexhull</span><span class="p">(</span><span class="n">bwimg</span><span class="p">):</span></div>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Calcuate the real convex hull of an image. The default convex hull algorithms, part of mahotas, returns the coordinates of the pixels on the hull. Therefore, that convex hull intersects with the outer pixels. Here we calculate the hull over a set containing the 4 border points of each pixel.</span>
<span class="sd">    </span>
<span class="sd">    :param bwimg: black-and-white image with 1 for occupied pixels and 0 at empty pixels</span>
<span class="sd">    :type bwimg: numpy array</span>
<span class="sd">    :return: numpy array of points in the hull    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># based on convexhull from mahotas.polygon</span>
    <span class="c"># extra points are added to prevent intersection between the hull and pixel centers</span>
    <span class="n">Y</span><span class="p">,</span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">bwimg</span><span class="p">)</span>
    <span class="n">ye</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">xe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>    
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">xe</span><span class="p">,</span><span class="n">ye</span><span class="p">))</span>
    <span class="n">P</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xe</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span><span class="n">ye</span><span class="p">[</span><span class="n">ind</span><span class="p">]))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">P</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_convex</span><span class="o">.</span><span class="n">convexhull</span><span class="p">(</span><span class="n">P</span><span class="p">))</span><span class="o">/</span><span class="mf">2.0</span>

<span class="k">def</span> <span class="nf">getCompactness</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">minval</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<div class="viewcode-block" id="getCompactness"><a class="viewcode-back" href="../AnalysisUtils.html#AnalysisUtils.getCompactness">[docs]</a>    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Calculate compactness of a morphology: :math:`\\frac{A_{\\text{area}}}{A_{\\text{convex hull}}}` .</span>

<span class="sd">    :param sigma: numpy array with cell id&#39;s</span>
<span class="sd">    :param minval: minimum cell id for non medium pixels</span>
<span class="sd">    :type minval: int</span>
<span class="sd">    :return: compactness</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># 1: create negative image</span>
    <span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span>    
    <span class="n">imneg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">im</span><span class="o">&gt;</span><span class="n">sigma</span><span class="p">)</span>
    <span class="c"># 2: find borders of negative image, these are all pixels where a neighbor is not cell</span>
    <span class="c">#    thus, all borders are 2 pixels thick! </span>
    <span class="n">bim</span> <span class="o">=</span> <span class="n">labeled</span><span class="o">.</span><span class="n">borders</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imneg</span><span class="p">))</span>    
    <span class="c"># 3: get convex hull with intersection between bim and imneg -&gt; the boundary pixels of the cells</span>
    <span class="c">#    ph is an array of points on the hull</span>
    <span class="c"># Note that the input are only the pixels on the border of the image, thus speeds up the </span>
    <span class="c"># calculations A LOT.</span>
    <span class="n">ph</span> <span class="o">=</span> <span class="n">realconvexhull</span><span class="p">(</span><span class="n">imneg</span><span class="o">&amp;</span><span class="n">bim</span><span class="p">)</span>
    <span class="c"># 4: calculate area of hull according to http://en.wikipedia.org/wiki/Polygon#Area_and_centroid</span>
    <span class="c">#    note that first point on the hull is added to the end for this calculation</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ph</span><span class="p">)</span>
    <span class="n">ph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">ph</span><span class="p">,</span><span class="n">ph</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]))</span>
    <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ph</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">ph</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ph</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">ph</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="c"># return compactness</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">imneg</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">getLCC</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span></div>
<div class="viewcode-block" id="getLCC"><a class="viewcode-back" href="../AnalysisUtils.html#AnalysisUtils.getLCC">[docs]</a>    <span class="sd">&quot;&quot;&quot; Find largest connected component of an image </span>
<span class="sd">    </span>
<span class="sd">    :param sigma: numpy array with cell id&#39;s</span>
<span class="sd">    :return: image with largest connected component</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lab</span><span class="p">,</span><span class="n">nr</span> <span class="o">=</span> <span class="n">labeled</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">lab</span><span class="p">,(</span><span class="n">lab</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">lab</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
    <span class="k">return</span> <span class="n">lab</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sizes</span><span class="o">==</span><span class="nb">max</span><span class="p">(</span><span class="n">sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">)]))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    
<span class="k">def</span> <span class="nf">getCellClusters</span><span class="p">(</span><span class="n">field</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">th</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span><span class="n">minlabsize</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">opendisk</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">mincellsize</span><span class="o">=.</span><span class="mi">25</span><span class="p">):</span>    </div>
<div class="viewcode-block" id="getCellClusters"><a class="viewcode-back" href="../AnalysisUtils.html#AnalysisUtils.getCellClusters">[docs]</a>    <span class="sd">&quot;&quot;&quot; Get clusters for a single morphology. Clusters are detected with the following steps:</span>
<span class="sd">        </span>
<span class="sd">        1) Remove all pixels that have a value in field higher than a given threshold.</span>
<span class="sd">        2) Detect blobs in remaining image with a labeling algorith:</span>
<span class="sd">            a. an opening operation may be performed before labeling.        </span>
<span class="sd">            b. areas smaller than a given size are ignored;</span>
<span class="sd">        3) Map each blob on the CPM grid:</span>
<span class="sd">            a. at least a given fraction of the cell must be on the labeled area.</span>
<span class="sd">        4) Check for cells in multiple clusters:</span>
<span class="sd">            a. remove cell from all but biggest cluster;</span>
<span class="sd">            b. remove cluster if it is empty after (a).</span>
<span class="sd">    </span>
<span class="sd">    :param field: numpy array with values on which data is seperated</span>
<span class="sd">    :param cells: dict with cell identifiers as keys and :class:`~OpenSimUtils.Cell.ClusterCell` instances as values</span>
<span class="sd">    :param sigma: CPM grid</span>
<span class="sd">    :param th: threshold value for step 1</span>
<span class="sd">    :param minlabsize: labelled areas smaller than this value are ignored (2b)</span>
<span class="sd">    :param opendisk: disk size for opening operation (2a)</span>
<span class="sd">    :param mincellsize: minimal fraction of the cell that must be on the labelled area to be added to the cluster</span>
<span class="sd">    :return: dictionary with cluster id as key and :class:`~OpenSimUtils.AnalysisUtils.Cluster` instances</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~OpenSimUtils.AnalysisUtils._getBlobs`, :class:`~OpenSimUtils.AnalysisUtils.Cluster` </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cfield</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
    <span class="n">cfield</span><span class="p">[</span><span class="n">field</span><span class="o">&lt;</span><span class="n">th</span><span class="p">]</span> <span class="o">=</span> <span class="mi">120</span>
    <span class="n">cfield</span><span class="p">[</span><span class="n">sigma</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">celldict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">cellid</span><span class="p">,[])</span> <span class="k">for</span> <span class="n">cellid</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">sigma</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">labnum</span><span class="p">,</span><span class="n">lab</span> <span class="o">=</span> <span class="n">_getBlobs</span><span class="p">(</span><span class="n">cfield</span><span class="p">,</span><span class="n">minsize</span><span class="o">=</span><span class="n">minlabsize</span><span class="p">,</span><span class="n">opendisk</span><span class="o">=</span><span class="n">opendisk</span><span class="p">)</span>
    <span class="n">clusters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">labnum</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">Cluster</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">cellpos</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lab</span><span class="o">==</span><span class="n">n</span><span class="p">)])</span>
        <span class="k">for</span> <span class="n">cellid</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">sigma</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">cellpos</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">cellid</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">mincellsize</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sigma</span><span class="o">==</span><span class="n">cellid</span><span class="p">):</span>                
                <span class="n">celldict</span><span class="p">[</span><span class="n">cellid</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">addCell</span><span class="p">(</span><span class="n">cellid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">getClusterSize</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">clusters</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
    <span class="n">nolab</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">cellid</span><span class="p">,</span><span class="n">labels</span> <span class="ow">in</span> <span class="n">celldict</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nolab</span> <span class="o">+=</span> <span class="mi">1</span>           
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">lc</span> <span class="o">=</span> <span class="p">[</span><span class="n">clusters</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span><span class="o">.</span><span class="n">getClusterSize</span><span class="p">()</span> <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]</span>
            <span class="n">cmax</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">lc</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">lc</span><span class="p">))]</span>
            <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lab</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">cmax</span><span class="p">:</span>
                    <span class="n">empty</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span><span class="o">.</span><span class="n">removeCell</span><span class="p">(</span><span class="n">cellid</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">empty</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">clusters</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">clusters</span>

<span class="k">def</span> <span class="nf">_getBlobs</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">minsize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">opendisk</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span></div>
    <span class="sd">&quot;&quot;&quot; Find blobs in an image. </span>
<span class="sd">    </span>
<span class="sd">    :param im: input image</span>
<span class="sd">    :type im: numpy array</span>
<span class="sd">    :param minsize: minimal size of detected blobs</span>
<span class="sd">    :type minsize: int</span>
<span class="sd">    :param opendisk: disk size for opening operation (ommitted when opendisk &lt;= 0)</span>
<span class="sd">    :type opendisk: int</span>
<span class="sd">    :return: identifiers for areas with blobs &gt; minsize and labeled image (lac,lab)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">opendisk</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span><span class="n">m</span><span class="o">.</span><span class="n">sedisk</span><span class="p">(</span><span class="n">opendisk</span><span class="p">))</span>  
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
    <span class="n">lab</span><span class="p">,</span><span class="n">nr</span> <span class="o">=</span> <span class="n">labeled</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">lab</span><span class="p">,(</span><span class="n">lab</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">lab</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
    <span class="n">lac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">sizes</span><span class="o">&gt;</span><span class="n">minsize</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">lac</span><span class="p">,</span><span class="n">lab</span>

<span class="k">def</span> <span class="nf">calcMSDTransForCellTC</span><span class="p">(</span><span class="n">com</span><span class="p">):</span>
<div class="viewcode-block" id="calcMSDTransForCellTC"><a class="viewcode-back" href="../AnalysisUtils.html#AnalysisUtils.calcMSDTransForCellTC">[docs]</a>    <span class="sd">&quot;&quot;&quot; Calculate the translational MSD for a single object.</span>
<span class="sd">    </span>
<span class="sd">    :param com: list of centers of mass at each time step</span>
<span class="sd">    :return: list with MSD for each time step</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">com</span><span class="o">-</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">calcMSDRotForCellTC</span><span class="p">(</span><span class="n">vecset</span><span class="p">):</span></div>
<div class="viewcode-block" id="calcMSDRotForCellTC"><a class="viewcode-back" href="../AnalysisUtils.html#AnalysisUtils.calcMSDRotForCellTC">[docs]</a>    <span class="sd">&quot;&quot;&quot; Calculate the rotational MSD for a single object.</span>
<span class="sd">    </span>
<span class="sd">    :param vecset: list of orientation vectors for each time step</span>
<span class="sd">    :return: list with MSD for each time step</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c"># 1) Calculate angles between two vectors of consecutive time steps: $a$, this is used to find the best fitting orientation of each cell:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">angle</span><span class="p">(</span><span class="n">vecset</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">vecset</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">vecset</span><span class="p">))])</span>
    <span class="c"># Find all indices in $a$ where the $a &gt; \frac{1}{2}\pi$; here the opposite orientation should be used</span>
    <span class="c"># Rotate the vector corresponding to that angle 180 degrees.</span>
    <span class="c"># Update angles that are calculated with that vector.</span>
    <span class="c"># Repeat these steps untill all angles are correct.</span>
    <span class="c"># Now we have a set of vectors which in which all cells have the most likely orientation: vecset</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">a</span><span class="o">&gt;.</span><span class="mi">5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">a</span><span class="o">&gt;.</span><span class="mi">5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">vecset</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">vecset</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">vecset</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">vecset</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">+</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">vecset</span><span class="p">):</span>
            <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">vecset</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span><span class="n">vecset</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c"># 2) Calculate the angle between the possitive x-axis and each vector</span>
    <span class="n">xa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">vecset</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">vecset</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
    <span class="c"># Remap these angles from the [0,-pi] domain to the [pi,2pi] domain.</span>
    <span class="n">xa</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">xa</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">+</span><span class="n">xa</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">xa</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)]</span>
    
    <span class="c"># 3) Calculate differences between consecutive angles</span>
    <span class="c"># calculate differences between angles</span>
    <span class="n">da</span> <span class="o">=</span> <span class="n">xa</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">xa</span><span class="p">)]</span> <span class="o">-</span> <span class="n">xa</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c"># detect transition over 2*np.pi and correct the angular differences</span>
    <span class="n">da</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">da</span><span class="o">&lt;-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">+</span><span class="n">da</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">da</span><span class="o">&lt;-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)]</span>
    <span class="n">da</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">da</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">+</span><span class="n">da</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">da</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)]</span>
    <span class="c"># summarize all angular differences to get a(t)-a(0) = sum(a(t)-a(t-1)) for eacht t</span>
    
    <span class="c"># 4) Calculate cumulative sum of the angles and square</span>
    <span class="n">sda</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">da</span><span class="p">)</span>   
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span><span class="n">sda</span><span class="p">)),</span><span class="mi">2</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Cluster</span><span class="p">:</span></div>
<div class="viewcode-block" id="Cluster"><a class="viewcode-back" href="../AnalysisUtils.html#AnalysisUtils.Cluster">[docs]</a>    <span class="sd">&quot;&quot;&quot; Container for a cell cluster</span>
<span class="sd">    </span>
<span class="sd">    :param id: cluster id</span>
<span class="sd">    :ivar cells: list of ids of the cells in the clusters</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="nb">id</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cellinterface</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ecminterface</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    
    <span class="k">def</span> <span class="nf">addCell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cellid</span><span class="p">):</span>
<div class="viewcode-block" id="Cluster.addCell"><a class="viewcode-back" href="../AnalysisUtils.html#AnalysisUtils.Cluster.addCell">[docs]</a>        <span class="sd">&quot;&quot;&quot; Add cell to cluster </span>
<span class="sd">        </span>
<span class="sd">        :param cellid: id of cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cellid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cellid</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">removeCell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cellid</span><span class="p">):</span></div>
<div class="viewcode-block" id="Cluster.removeCell"><a class="viewcode-back" href="../AnalysisUtils.html#AnalysisUtils.Cluster.removeCell">[docs]</a>        <span class="sd">&quot;&quot;&quot; Remove cell from cluster</span>
<span class="sd">        </span>
<span class="sd">        :param cellid: id of cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cellid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">cellid</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    
    <span class="k">def</span> <span class="nf">getClusterSize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span></div>
<div class="viewcode-block" id="Cluster.getClusterSize"><a class="viewcode-back" href="../AnalysisUtils.html#AnalysisUtils.Cluster.getClusterSize">[docs]</a>        <span class="sd">&quot;&quot;&quot; Calculate number of cell in cluster</span>
<span class="sd">        </span>
<span class="sd">        :return: number of cells in cluster</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">ClusterCellTC</span><span class="p">():</span></div></div>
<div class="viewcode-block" id="ClusterCellTC"><a class="viewcode-back" href="../AnalysisUtils.html#AnalysisUtils.ClusterCellTC">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="nb">id</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusterId</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusterSize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">laxis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">com</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">addTimeStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">pix</span><span class="p">,</span><span class="n">cid</span><span class="p">,</span><span class="n">csz</span><span class="p">):</span>   
<div class="viewcode-block" id="ClusterCellTC.addTimeStep"><a class="viewcode-back" href="../AnalysisUtils.html#AnalysisUtils.ClusterCellTC.addTimeStep">[docs]</a>        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,(</span><span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">com</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">com</span><span class="p">,</span><span class="n">getCoM</span><span class="p">(</span><span class="n">pix</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">laxis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">laxis</span><span class="p">,</span><span class="n">getCellOrientation</span><span class="p">(</span><span class="n">pix</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusterId</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusterId</span><span class="p">,(</span><span class="n">cid</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusterSize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusterSize</span><span class="p">,(</span><span class="n">csz</span><span class="p">))</span>  
</pre></div></div></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../MIMBSimUtils.html">MIMB SimUtils 1.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Margriet Palm.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>