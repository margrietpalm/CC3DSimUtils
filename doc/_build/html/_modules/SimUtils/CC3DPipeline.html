
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>SimUtils.CC3DPipeline &mdash; MIMB SimUtils 1.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="MIMB SimUtils 1.0 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../CC3DSimUtils.html">MIMB SimUtils 1.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for SimUtils.CC3DPipeline</h1><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span><span class="nn">gzip</span><span class="o">,</span><span class="nn">string</span><span class="o">,</span><span class="nn">time</span><span class="o">,</span><span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">Image</span>
<span class="c">#~ from CC3DTools.CC3DReaders import *</span>
<span class="kn">from</span> <span class="nn">.AnalysisUtils</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.ImageUtils</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.Readers</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.Cell</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
<span class="c">#from Compactness import getCompactness</span>
<span class="c">#from DrawCells import drawCells</span>

<span class="c">## @package SimUtils.CC3DPipeline </span>
<span class="c"># Utility functions for a simulation pipeline (as used on the cluster).</span>

<div class="viewcode-block" id="makeImages"><a class="viewcode-back" href="../../CC3DPipeline.html#SimUtils.CC3DPipeline.makeImages">[docs]</a><span class="k">def</span> <span class="nf">makeImages</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">trange</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">outpath</span><span class="p">,</span><span class="n">cm</span><span class="o">=</span><span class="s">&#39;default.ctb&#39;</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">timestamp</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">bc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">fieldname</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">border</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Make images for a single simulation simulation</span>
<span class="sd">        </span>
<span class="sd">    :param id: simulation identifier</span>
<span class="sd">    :type id: str</span>
<span class="sd">    :param trange: list of mcs to draw</span>
<span class="sd">    :param inpath: path containing data files</span>
<span class="sd">    :type inpath: str</span>
<span class="sd">    :param outpath: path to save images to</span>
<span class="sd">    :type outpath: str</span>
<span class="sd">    :param cm: file containing the colormap</span>
<span class="sd">    :type cm: str</span>
<span class="sd">    :param gzipped: data is gzipped</span>
<span class="sd">    :type gzipped: bool</span>
<span class="sd">    :param timestamp: add time stamp to the image</span>
<span class="sd">    :type timestamp: bool</span>
<span class="sd">    :param label: add id as label to the image</span>
<span class="sd">    :type label: bool</span>
<span class="sd">    :param scale: scaling of the image</span>
<span class="sd">    :type scale: number</span>
<span class="sd">    :param bc: color of cell boundaries (r,g,b)</span>
<span class="sd">    :param fontsize: size of the fonts used for label and time stamp; font size will be multiplied by scale.</span>
<span class="sd">    :type fontsize: int</span>
<span class="sd">    :param fieldname: name of chemical field</span>
<span class="sd">    :type fieldname: str</span>
<span class="sd">    :param border: cut of border pixels</span>
<span class="sd">    :type border: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">tlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">trange</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">colormap</span> <span class="o">=</span> <span class="n">readColorMap</span><span class="p">(</span><span class="n">cm</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trange</span><span class="p">:</span>
        <span class="n">outfile</span> <span class="o">=</span> <span class="nb">id</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">+</span><span class="n">string</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">tlen</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;.png&#39;</span>    
        <span class="n">im</span> <span class="o">=</span> <span class="n">makeImage</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">colormap</span><span class="p">,</span><span class="n">timestamp</span><span class="p">,</span><span class="n">label</span><span class="p">,</span><span class="n">scale</span><span class="p">,</span><span class="n">bc</span><span class="p">,</span><span class="n">fontsize</span><span class="p">,</span><span class="n">border</span><span class="p">,</span><span class="n">gzipped</span><span class="p">,</span><span class="n">fieldname</span><span class="p">)</span>
        <span class="n">im</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">outpath</span><span class="o">+</span><span class="n">outfile</span><span class="p">)</span>
    <span class="k">print</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trange</span><span class="p">))</span> <span class="o">+</span> <span class="s">&#39; images drawn in &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; seconds&#39;</span>
</div>
<span class="k">def</span> <span class="nf">makeImagesMC</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">trange</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">outpath</span><span class="p">,</span><span class="n">cm</span><span class="o">=</span><span class="s">&#39;default.ctb&#39;</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">timestamp</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">bc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">fieldname</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">border</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">ncores</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Make images for a single simulation simulation, using multiple processors</span>
<span class="sd">        </span>
<span class="sd">    :param id: simulation identifier</span>
<span class="sd">    :type id: str</span>
<span class="sd">    :param trange: list of mcs to draw</span>
<span class="sd">    :param inpath: path containing data files</span>
<span class="sd">    :type inpath: str</span>
<span class="sd">    :param outpath: path to save images to</span>
<span class="sd">    :type outpath: str</span>
<span class="sd">    :param cm: file containing the colormap</span>
<span class="sd">    :type cm: str</span>
<span class="sd">    :param gzipped: data is gzipped</span>
<span class="sd">    :type gzipped: bool</span>
<span class="sd">    :param timestamp: add time stamp to the image</span>
<span class="sd">    :type timestamp: bool</span>
<span class="sd">    :param label: add id as label to the image</span>
<span class="sd">    :type label: bool</span>
<span class="sd">    :param scale: scaling of the image</span>
<span class="sd">    :type scale: number</span>
<span class="sd">    :param bc: color of cell boundaries (r,g,b)</span>
<span class="sd">    :param fontsize: size of the fonts used for label and time stamp; font size will be multiplied by scale.</span>
<span class="sd">    :type fontsize: int</span>
<span class="sd">    :param fieldname: name of chemical field</span>
<span class="sd">    :type fieldname: str</span>
<span class="sd">    :param border: cut of border pixels</span>
<span class="sd">    :type border: bool</span>
<span class="sd">    :param ncores: number of cores that may be used</span>
<span class="sd">    :type ncores: int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c">#~ print os.getcwd()</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">tlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">trange</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">colormap</span> <span class="o">=</span> <span class="n">readColorMap</span><span class="p">(</span><span class="n">cm</span><span class="p">)</span>
    <span class="n">jobs</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">id</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">postfix</span><span class="p">,</span><span class="n">colormap</span><span class="p">,</span><span class="n">outpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">+</span><span class="n">string</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">tlen</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;.png&#39;</span><span class="p">,</span> \
             <span class="n">timestamp</span><span class="p">,</span><span class="n">label</span><span class="p">,</span><span class="n">scale</span><span class="p">,</span><span class="n">bc</span><span class="p">,</span><span class="n">fontsize</span><span class="p">,</span><span class="n">border</span><span class="p">,</span><span class="n">gzipped</span><span class="p">,</span><span class="n">fieldname</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trange</span><span class="p">]</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">ncores</span><span class="p">)</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">makeImageMC</span><span class="p">,</span><span class="n">jobs</span><span class="p">)</span>
    <span class="k">print</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trange</span><span class="p">))</span> <span class="o">+</span> <span class="s">&#39; images drawn in &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; seconds&#39;</span>

<span class="k">def</span> <span class="nf">makeImageMC</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Wrapper function for :func:`~SimUtils.CC3DPipeline.makeImage` to work with multiprocessing</span>
<span class="sd">    </span>
<span class="sd">    :param args: list of all arguments of :func:`~SimUtils.CC3DPipeline.makeImage`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">[</span><span class="nb">id</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">colormap</span><span class="p">,</span><span class="n">outfile</span><span class="p">,</span><span class="n">timestamp</span><span class="p">,</span><span class="n">label</span><span class="p">,</span><span class="n">scale</span><span class="p">,</span><span class="n">bc</span><span class="p">,</span><span class="n">fontsize</span><span class="p">,</span><span class="n">border</span><span class="p">,</span><span class="n">gzipped</span><span class="p">,</span><span class="n">fieldname</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">makeImage</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">colormap</span><span class="p">,</span><span class="n">timestamp</span><span class="p">,</span><span class="n">label</span><span class="p">,</span><span class="n">scale</span><span class="p">,</span><span class="n">bc</span><span class="p">,</span><span class="n">fontsize</span><span class="p">,</span><span class="n">border</span><span class="p">,</span><span class="n">gzipped</span><span class="p">,</span><span class="n">fieldname</span><span class="p">)</span>
    <span class="n">im</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">outfile</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">makeImage</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">colormap</span><span class="p">,</span><span class="n">timestamp</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">bc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">border</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">fieldname</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Draw morphology for one timestep </span>
<span class="sd">    </span>
<span class="sd">    :param id: simulation identifier</span>
<span class="sd">    :param inpath: path containing data files</span>
<span class="sd">    :param t: time step</span>
<span class="sd">    :param outpath: path to save images to</span>
<span class="sd">    :param colormap: dictionary with cell types as keys and colors (r,g,b) as values</span>
<span class="sd">    :param timestamp: add time stamp to the image</span>
<span class="sd">    :type timestamp: bool</span>
<span class="sd">    :param label: add id as label to the image</span>
<span class="sd">    :type label: bool</span>
<span class="sd">    :param scale: scaling of the image</span>
<span class="sd">    :type scale: number    </span>
<span class="sd">    :param bc: color of cell boundaries (r,g,b)</span>
<span class="sd">    :param fontsize: size of the fonts used for label and time stamp; font size will be multiplied by scale.</span>
<span class="sd">    :type fontsize: int    </span>
<span class="sd">    :param border: cut of border pixels</span>
<span class="sd">    :type border: bool</span>
<span class="sd">    :param gzipped: data is gzipped</span>
<span class="sd">    :type gzipped: bool    </span>
<span class="sd">    :param fieldname: name of chemical field</span>
<span class="sd">    :type fieldname: str    </span>
<span class="sd">    :return: image object</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~SimUtils.ImageUtils.drawCells`, :func:`~SimUtils.ImageUtils.addTimeStamp`, :func:`~SimUtils.ImageUtils.addLabel`    </span>
<span class="sd">    &quot;&quot;&quot;</span>          
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">readSigma</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">gzipped</span><span class="p">,</span><span class="n">border</span><span class="p">)</span>
    <span class="n">types</span> <span class="o">=</span> <span class="n">readTau</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">gzipped</span><span class="p">,</span><span class="n">border</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fieldname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">readChemField</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">fieldname</span><span class="p">,</span><span class="n">gzipped</span><span class="p">,</span><span class="n">border</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span> 
    <span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">drawCells</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">types</span><span class="p">,</span><span class="n">field</span><span class="p">,</span><span class="n">colormap</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">nx</span><span class="o">=</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="o">=</span><span class="n">ny</span><span class="p">,</span><span class="n">bc</span><span class="o">=</span><span class="n">bc</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">timestamp</span><span class="p">:</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fontsize</span><span class="o">*</span><span class="p">(</span><span class="n">nx</span><span class="o">/</span><span class="mf">200.0</span><span class="p">)</span><span class="o">*</span><span class="n">scale</span><span class="p">)</span>
        <span class="n">addTimeStamp</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">fs</span><span class="p">,</span><span class="n">fc</span><span class="o">=</span><span class="n">bc</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">label</span><span class="p">:</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1.25</span><span class="o">*</span><span class="n">fontsize</span><span class="o">*</span><span class="p">(</span><span class="n">nx</span><span class="o">/</span><span class="mf">200.0</span><span class="p">)</span><span class="o">*</span><span class="n">scale</span><span class="p">)</span>
        <span class="n">addLabel</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">),</span><span class="n">fs</span><span class="p">,</span><span class="n">fc</span><span class="o">=</span><span class="n">bc</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">im</span>

<span class="k">def</span> <span class="nf">getNodesAndDrawOnMorph</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">trange</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">outpath</span><span class="p">,</span><span class="n">closedisk</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">thinloop</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">d</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">cm</span><span class="o">=</span><span class="s">&#39;default.ctb&#39;</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate nodes for a simulations and draw nodes on the morphology </span>
<span class="sd">    </span>
<span class="sd">    :param id: simulation identifier</span>
<span class="sd">    :param trange: list of time steps</span>
<span class="sd">    :param inpath: path containing data files</span>
<span class="sd">    :param outpath: path to save images to</span>
<span class="sd">    :param closedisk: size of the disk used for closing.</span>
<span class="sd">    :param thinloop: number of thinning iterations.</span>
<span class="sd">    :param d: minimal distance between two branchpoints.</span>
<span class="sd">    :param cm file: containing the colormap    </span>
<span class="sd">    :param gzipped: if True, data is expected to be gzipped, and stored in inpath/id/</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~SimUtils.AnalysisUtils.getNodes`, :func:`~SimUtils.AnalysisUtils.drawNodesColored`</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">tlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">trange</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">colormap</span> <span class="o">=</span> <span class="n">readColorMap</span><span class="p">(</span><span class="n">cm</span><span class="p">)</span>
    <span class="n">postfix</span> <span class="o">=</span> <span class="s">&#39;.data&#39;</span>
    <span class="k">if</span> <span class="n">gzipped</span><span class="p">:</span>
        <span class="n">postfix</span> <span class="o">+=</span> <span class="s">&#39;.gz&#39;</span>
        <span class="n">inpath</span> <span class="o">+=</span> <span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;/&#39;</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trange</span><span class="p">:</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">inpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_TF_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">+</span><span class="n">postfix</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">&gt;</span><span class="mi">0</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>             
        <span class="n">nodes</span><span class="p">,</span><span class="n">skel</span> <span class="o">=</span> <span class="n">getNodes</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">closedisk</span><span class="o">=</span><span class="n">closedisk</span><span class="p">,</span><span class="n">thinloop</span><span class="o">=</span><span class="n">thinloop</span><span class="p">)</span>
        <span class="n">endpoints</span> <span class="o">=</span> <span class="n">getEndPoints</span><span class="p">(</span><span class="n">skel</span><span class="p">,</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">endpoints</span><span class="p">:</span>
            <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span>        
        <span class="n">im</span> <span class="o">=</span> <span class="n">makeImage</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">postfix</span><span class="p">,</span><span class="n">colormap</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">)</span>
        <span class="n">colormapNodes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">i</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)))</span>
        <span class="n">nodedict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">))</span>
        <span class="c">#~ colormapNodes = {i:(0,0,0) for i in range(len(nodes))}</span>
        <span class="c">#~ nodedict = {i:node for i,node in enumerate(nodes)}</span>
        <span class="n">outfile</span> <span class="o">=</span> <span class="nb">id</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">+</span><span class="n">string</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">tlen</span><span class="p">)</span>
        <span class="n">drawNodesColored</span><span class="p">(</span><span class="n">nodedict</span><span class="p">,</span><span class="n">im</span><span class="p">,</span><span class="n">outpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="n">outfile</span><span class="p">,</span><span class="n">colormapNodes</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">r</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>        
        <span class="c">#~ im.save(outpath+outfile)        </span>
    <span class="k">print</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trange</span><span class="p">))</span> <span class="o">+</span> <span class="s">&#39; images drawn in &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; seconds&#39;</span>    

<span class="k">def</span> <span class="nf">getNodesAndSkelOnMorph</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">trange</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">outpath</span><span class="p">,</span><span class="n">closedisk</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">thinloop</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">d</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">cm</span><span class="o">=</span><span class="s">&#39;default.ctb&#39;</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate nodes for a simulations and draw nodes on the morphology together with the skeleton.</span>
<span class="sd">    </span>
<span class="sd">    :param id: simulation identifier</span>
<span class="sd">    :param trange: list of time steps</span>
<span class="sd">    :param inpath: path containing data files</span>
<span class="sd">    :param outpath: path to save images to</span>
<span class="sd">    :param closedisk: size of the disk used for closing.</span>
<span class="sd">    :param thinloop: number of thinning iterations.</span>
<span class="sd">    :param d: minimal distance between two branchpoints.</span>
<span class="sd">    :param cm file: containing the colormap    </span>
<span class="sd">    :param gzipped: if True, data is expected to be gzipped, and stored in inpath/id/</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~SimUtils.AnalysisUtils.getNodes`, :func:`~SimUtils.AnalysisUtils.drawNodesColored`</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">tlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">trange</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">colormap</span> <span class="o">=</span> <span class="n">readColorMap</span><span class="p">(</span><span class="n">cm</span><span class="p">)</span>
    <span class="n">postfix</span> <span class="o">=</span> <span class="s">&#39;.data&#39;</span>
    <span class="k">if</span> <span class="n">gzipped</span><span class="p">:</span>
        <span class="n">postfix</span> <span class="o">+=</span> <span class="s">&#39;.gz&#39;</span>
        <span class="n">inpath</span> <span class="o">+=</span> <span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;/&#39;</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trange</span><span class="p">:</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">inpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_TF_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">+</span><span class="n">postfix</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">&gt;</span><span class="mi">0</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>             
        <span class="n">nodes</span><span class="p">,</span><span class="n">skel</span> <span class="o">=</span> <span class="n">getNodes</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">closedisk</span><span class="o">=</span><span class="n">closedisk</span><span class="p">,</span><span class="n">thinloop</span><span class="o">=</span><span class="n">thinloop</span><span class="p">,</span><span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
        <span class="n">endpoints</span> <span class="o">=</span> <span class="n">getEndPoints</span><span class="p">(</span><span class="n">skel</span><span class="p">,</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">endpoints</span><span class="p">:</span>
            <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span>        
        <span class="n">edges</span> <span class="o">=</span> <span class="n">getEdges</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="n">skel</span><span class="p">)</span>
        <span class="n">nnodes</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">con</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">con</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">colormapNodes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">i</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)))</span>            
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">con</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">con</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">colormapNodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">150</span><span class="p">,</span><span class="mi">150</span><span class="p">,</span><span class="mi">150</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">con</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">colormapNodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">nnodes</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">makeImage</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">postfix</span><span class="p">,</span><span class="n">colormap</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">bc</span><span class="o">=</span><span class="p">(</span><span class="mi">180</span><span class="p">,</span><span class="mi">180</span><span class="p">,</span><span class="mi">180</span><span class="p">))</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">)</span>
        <span class="n">nodedict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">))</span>
        <span class="c">#~ colormapNodes = {i:(0,0,0) for i in range(len(nodes))}</span>
        <span class="c">#~ nodedict = {i:node for i,node in enumerate(nodes)}</span>
        <span class="n">outfile</span> <span class="o">=</span> <span class="nb">id</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">+</span><span class="n">string</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">tlen</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">drawSkelOnMorph</span><span class="p">(</span><span class="n">skel</span><span class="p">,</span><span class="n">im</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">save</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">drawNodesColored</span><span class="p">(</span><span class="n">nodedict</span><span class="p">,</span><span class="n">im</span><span class="p">,</span><span class="n">outpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="n">outfile</span><span class="p">,</span><span class="n">colormapNodes</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">r</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>        
        <span class="c">#~ im.save(outpath+outfile)        </span>
    <span class="k">print</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trange</span><span class="p">))</span> <span class="o">+</span> <span class="s">&#39; images drawn in &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; seconds&#39;</span>    

<span class="k">def</span> <span class="nf">getConnectedEdgesOnMorph</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">trange</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">outpath</span><span class="p">,</span><span class="n">closedisk</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">thinloop</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">d</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">cm</span><span class="o">=</span><span class="s">&#39;default.ctb&#39;</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate nodes for a simulations and draw nodes on the morphology </span>
<span class="sd">    </span>
<span class="sd">    :param id: simulation identifier</span>
<span class="sd">    :param trange: list of time steps</span>
<span class="sd">    :param inpath: path containing data files</span>
<span class="sd">    :param outpath: path to save images to</span>
<span class="sd">    :param closedisk: size of the disk used for closing.</span>
<span class="sd">    :param thinloop: number of thinning iterations.</span>
<span class="sd">    :param d: minimal distance between two branchpoints.</span>
<span class="sd">    :param cm file: containing the colormap    </span>
<span class="sd">    :param gzipped: if True, data is expected to be gzipped, and stored in inpath/id/</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~SimUtils.AnalysisUtils.getNodes`, :func:`~SimUtils.AnalysisUtils.drawNodesColored`</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">tlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">trange</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">colormap</span> <span class="o">=</span> <span class="n">readColorMap</span><span class="p">(</span><span class="n">cm</span><span class="p">)</span>
    <span class="n">postfix</span> <span class="o">=</span> <span class="s">&#39;.data&#39;</span>
    <span class="k">if</span> <span class="n">gzipped</span><span class="p">:</span>
        <span class="n">postfix</span> <span class="o">+=</span> <span class="s">&#39;.gz&#39;</span>
        <span class="n">inpath</span> <span class="o">+=</span> <span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;/&#39;</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trange</span><span class="p">:</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">inpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_TF_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">+</span><span class="n">postfix</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">&gt;</span><span class="mi">0</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>             
        <span class="n">nodes</span><span class="p">,</span><span class="n">skel</span> <span class="o">=</span> <span class="n">getNodes</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">closedisk</span><span class="o">=</span><span class="n">closedisk</span><span class="p">,</span><span class="n">thinloop</span><span class="o">=</span><span class="n">thinloop</span><span class="p">,</span><span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
        <span class="n">endpoints</span> <span class="o">=</span> <span class="n">getEndPoints</span><span class="p">(</span><span class="n">skel</span><span class="p">,</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">endpoints</span><span class="p">:</span>
            <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span>        
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">mergeNodes</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="n">d</span><span class="p">)</span>            
        <span class="n">con</span> <span class="o">=</span> <span class="n">getNofEdges</span><span class="p">(</span><span class="n">nodelist</span><span class="p">,</span><span class="n">skel</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">nodes</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">con</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">nodes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> 
        <span class="n">colormapNodes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">i</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)))</span>                                
        <span class="n">im</span> <span class="o">=</span> <span class="n">makeImage</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">postfix</span><span class="p">,</span><span class="n">colormap</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">bc</span><span class="o">=</span><span class="p">(</span><span class="mi">180</span><span class="p">,</span><span class="mi">180</span><span class="p">,</span><span class="mi">180</span><span class="p">))</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">drawSkelOnMorph</span><span class="p">(</span><span class="n">skel</span><span class="p">,</span><span class="n">im</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">save</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>            
        <span class="n">nodedict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">))</span>
        <span class="n">outfile</span> <span class="o">=</span> <span class="nb">id</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">+</span><span class="n">string</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">tlen</span><span class="p">)</span>
        <span class="n">drawNodesColored</span><span class="p">(</span><span class="n">nodedict</span><span class="p">,</span><span class="n">im</span><span class="p">,</span><span class="n">outpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="n">outfile</span><span class="p">,</span><span class="n">colormapNodes</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">r</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>        
    <span class="k">print</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trange</span><span class="p">))</span> <span class="o">+</span> <span class="s">&#39; images drawn in &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; seconds&#39;</span>    

<div class="viewcode-block" id="getCompactnessForSim"><a class="viewcode-back" href="../../CC3DPipeline.html#SimUtils.CC3DPipeline.getCompactnessForSim">[docs]</a><span class="k">def</span> <span class="nf">getCompactnessForSim</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">trange</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">outpath</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">border</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate compactness for one simulation</span>
<span class="sd">    </span>
<span class="sd">    :param id: simulation identifier</span>
<span class="sd">    :param trange: range of mcs to calculate</span>
<span class="sd">    :param inpath: path containing data files    </span>
<span class="sd">    :param gzipped: if True, data is expected to be gzipped, and stored in inpath/id/</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~SimUtils.AnalysisUtils.getCompactness`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">outpath</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">outpath</span> <span class="o">=</span> <span class="n">inpath</span>
    <span class="k">if</span> <span class="n">gzipped</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">outpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_compactness.data.gz&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">outpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_compactness.data&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>    
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">trange</span><span class="p">),</span><span class="mi">2</span><span class="p">))</span>            
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trange</span><span class="p">):</span>            
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">readSigma</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">gzipped</span><span class="p">,</span><span class="n">border</span><span class="p">)</span>          
        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">,</span><span class="n">getCompactness</span><span class="p">(</span><span class="n">getLCC</span><span class="p">(</span><span class="n">sigma</span><span class="p">))]</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;#MCS</span><span class="se">\t</span><span class="s">compactness</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&#39;compactness calculated for &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trange</span><span class="p">))</span><span class="o">+</span><span class="s">&#39; morphologies in &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; seconds&#39;</span>
</div>
<span class="k">def</span> <span class="nf">getNodesAndEdges</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">merge</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">purge</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">closedisk</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">thinloop</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span><span class="n">d</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">w</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">nodedist</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate nodes and edges for single morphology</span>
<span class="sd">    </span>
<span class="sd">    :param sigma: CPM grid</span>
<span class="sd">    :param merge: merge nodes that are too close</span>
<span class="sd">    :type merge: bool</span>
<span class="sd">    :param purge: purge nodes that connect two nodes</span>
<span class="sd">    :type purge: bool</span>
<span class="sd">    :param closedisk: size of the disk used for closing.</span>
<span class="sd">    :param thinloop: number of thinning iterations.</span>
<span class="sd">    :param d: minimal distance between two branchpoints (used in node detection)</span>
<span class="sd">    :param w: node width that will be cut out of the first image</span>
<span class="sd">    :param nodedist: minimal distance betweeen to nodes (used in merging of nodes)</span>
<span class="sd">    :return: dictionary with nodes {nodeid : (x,y)}, list of edges [(source,target)], skeleton image</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~SimUtils.AnalysisUtils.getNodes`, :func:`~SimUtils.AnalysisUtils.getEndPoints`, :func:`~SimUtils.AnalysisUtils.getEdges`, :func:`~SimUtils.AnalysisUtils.mergeNodesAndEdges`, :func:`~SimUtils.AnalysisUtils.purgeNodes`,</span>
<span class="sd">    &quot;&quot;&quot;</span>  
    <span class="n">nodes</span><span class="p">,</span><span class="n">skel</span> <span class="o">=</span> <span class="n">getNodes</span><span class="p">(</span><span class="n">sigma</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span><span class="n">closedisk</span><span class="o">=</span><span class="n">closedisk</span><span class="p">,</span><span class="n">thinloop</span><span class="o">=</span><span class="n">thinloop</span><span class="p">,</span><span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
    <span class="n">endpoints</span> <span class="o">=</span> <span class="n">getEndPoints</span><span class="p">(</span><span class="n">skel</span><span class="p">,</span><span class="n">nodes</span><span class="p">,</span><span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">endpoints</span><span class="p">:</span>
        <span class="n">nodes</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ep</span>
        <span class="c">#~ nodes.append(ep)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">getEdges</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="n">skel</span><span class="p">,</span><span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">merge</span><span class="p">:</span>
        <span class="n">nodes</span><span class="p">,</span><span class="n">edges</span> <span class="o">=</span> <span class="n">mergeNodesAndEdges</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span><span class="n">d</span><span class="o">=</span><span class="n">nodedist</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">purge</span><span class="p">:</span>
        <span class="n">nodes</span><span class="p">,</span><span class="n">edges</span> <span class="o">=</span> <span class="n">purgeNodes</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="n">edges</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nodes</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span><span class="n">skel</span>

<span class="k">def</span> <span class="nf">getTypesOnTipsForSim</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">trange</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">typenames</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">border</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Count occurance of cell typs on sprout end points for a simulation</span>
<span class="sd">    </span>
<span class="sd">    :param id: simulation id</span>
<span class="sd">    :param trange: list of MCS</span>
<span class="sd">    :param inpath: path to simulation data</span>
<span class="sd">    :param typename: dict with {typeID : typename}</span>
<span class="sd">    :param gzipped: data is gzipped</span>
<span class="sd">    :type gzipped: bool</span>
<span class="sd">    :param border: CPM field is surrounded by a 1 pixel thick border cell</span>
<span class="sd">    :type border: bool</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~SimUtils.CC3DPipeline.getNodesAndEdges`, :class:`~SimUtils.AnalysisUtils.TipFinder`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">gzipped</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">inpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_TIPS.data.gz&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>    
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">inpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_TIPS.data&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;#MCS</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">typenames</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">typenames</span><span class="p">]))</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trange</span><span class="p">:</span>
        <span class="c">#~ print t</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">readSigma</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="n">gzipped</span><span class="p">,</span><span class="n">border</span><span class="o">=</span><span class="n">border</span><span class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">readTau</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="n">gzipped</span><span class="p">,</span><span class="n">border</span><span class="o">=</span><span class="n">border</span><span class="p">)</span>        
        <span class="n">nodes</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span><span class="n">skel</span> <span class="o">=</span> <span class="n">getNodesAndEdges</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">closedisk</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">thinloop</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span><span class="n">d</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">tf</span> <span class="o">=</span> <span class="n">TipFinder</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">tau</span><span class="p">,</span><span class="n">nodes</span><span class="p">,</span><span class="n">edges</span><span class="p">)</span>
        <span class="n">tips</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">findAllCellsOnTips</span><span class="p">()</span>
        <span class="n">tiptypes</span> <span class="o">=</span> <span class="n">tips</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">tiptypes</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="nb">type</span><span class="p">))</span> <span class="k">for</span> <span class="nb">type</span> <span class="ow">in</span> <span class="n">typenames</span><span class="p">]))</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">doMorphometry</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">trange</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">save</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">closedisk</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">thinloop</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span><span class="n">d</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate morphometrics with default settings for one simulation. All morphometrics are collected and save in a file inpath/id_morph.data.gz</span>
<span class="sd">    </span>
<span class="sd">    :param id: simulation identifier</span>
<span class="sd">    :param trange: range of mcs to calculate</span>
<span class="sd">    :param inpath: path containing data files    </span>
<span class="sd">    :param gzipped: if True, data is expected to be gzipped, and stored in inpath/id/</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~SimUtils.CC3DPipeline.getNodesAndEdges`</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> 
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">trange</span><span class="p">),</span><span class="mi">9</span><span class="p">))</span>            
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trange</span><span class="p">):</span>            
        <span class="k">if</span> <span class="n">gzipped</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">inpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_TF_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;.data.gz&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">inpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_TF_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;.data&#39;</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">&gt;</span><span class="mi">0</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>             
        <span class="n">c</span> <span class="o">=</span> <span class="n">getCompactness</span><span class="p">(</span><span class="n">getLCC</span><span class="p">(</span><span class="n">im</span><span class="p">))</span>
        <span class="n">meshes</span> <span class="o">=</span> <span class="n">getMeshes</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>  
        <span class="n">nodes</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span><span class="n">skel</span> <span class="o">=</span> <span class="n">getNodesAndEdges</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>        
        <span class="n">degree</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edges</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>      
        <span class="n">nEP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">degree</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">nBP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">degree</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">nEdges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">meshes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span><span class="n">nEdges</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">meshes</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">meshes</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">meshes</span><span class="p">),</span><span class="n">nEP</span><span class="p">,</span><span class="n">nBP</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span><span class="n">nEdges</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">nEP</span><span class="p">,</span><span class="n">nBP</span><span class="p">]</span>            
    <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">gzipped</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">inpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_morph.data.gz&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">inpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_morph.data.gz&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>   
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;#MCS</span><span class="se">\t</span><span class="s">compactness</span><span class="se">\t</span><span class="s">nnodes</span><span class="se">\t</span><span class="s">nnedges</span><span class="se">\t</span><span class="s">nmeshes</span><span class="se">\t</span><span class="s">meshAavg</span><span class="se">\t</span><span class="s">meshAstd</span><span class="se">\t</span><span class="s">nEP</span><span class="se">\t</span><span class="s">nBP</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;#MCS</span><span class="se">\t</span><span class="s">compactness</span><span class="se">\t</span><span class="s">nnodes</span><span class="se">\t</span><span class="s">nnedges</span><span class="se">\t</span><span class="s">nmeshes</span><span class="se">\t</span><span class="s">meshAavg</span><span class="se">\t</span><span class="s">meshAstd</span><span class="se">\t</span><span class="s">nEP</span><span class="se">\t</span><span class="s">nBP</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="k">return</span> <span class="n">data</span>
    <span class="k">print</span> <span class="s">&#39;mophometrics calculated for &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trange</span><span class="p">))</span><span class="o">+</span><span class="s">&#39; morphologies in &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; seconds&#39;</span>


<span class="k">def</span> <span class="nf">calcOrderParameter</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">trange</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">radii</span><span class="p">,</span><span class="n">border</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">weighted</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">outpath</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Function to call :func:`~SimUtils.CC3DPipeline.getOrderParameterForSim`, needed for compatibility &quot;&quot;&quot;</span>
    <span class="n">getOrderParameterForSim</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">trange</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">radii</span><span class="p">,</span><span class="n">border</span><span class="p">,</span><span class="n">gzipped</span><span class="p">,</span><span class="n">weighted</span><span class="p">,</span><span class="n">outpath</span><span class="p">)</span>
    
<div class="viewcode-block" id="getOrderParameterForSim"><a class="viewcode-back" href="../../CC3DPipeline.html#SimUtils.CC3DPipeline.getOrderParameterForSim">[docs]</a><span class="k">def</span> <span class="nf">getOrderParameterForSim</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">trange</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">radii</span><span class="p">,</span><span class="n">border</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">weighted</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">outpath</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate orderparameters for one simulation. All order parameters are collected and save in a file inpath/id_orderparameter.data</span>
<span class="sd">    </span>
<span class="sd">    :param id: simulation identifier</span>
<span class="sd">    :param trange: range of mcs to calculate</span>
<span class="sd">    :param inpath: path containing data files    </span>
<span class="sd">    :param radii: list of radii for wich the order parameter is calculates</span>
<span class="sd">    :param border: remove border pixels from data</span>
<span class="sd">    :param gzipped: if True, data is expected to be gzipped, and stored in inpath/id/, and the output file will be gzipped.</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~SimUtils.AnalysisUtils.getOrderParameter`</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="k">if</span> <span class="n">outpath</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">outpath</span> <span class="o">=</span> <span class="n">inpath</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">gzipped</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">outpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_orderparameter.data.gz&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">outpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_orderparameter.data&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">trange</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">radii</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;#MCS&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">radii</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trange</span><span class="p">):</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">readSigma</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">gzipped</span><span class="p">,</span><span class="n">border</span><span class="p">)</span>
        <span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">getAngleField</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">radii</span><span class="p">):</span>
            <span class="c">#~ data[i,j+1] = getOrderParameter(cells,sigma,r,weighted)</span>
            <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">getOrderParameterFromGrid</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">angles</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">weighted</span><span class="p">)</span>          
    <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&#39;Order parameter calculated for &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trange</span><span class="p">))</span><span class="o">+</span><span class="s">&#39; simulations and &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">radii</span><span class="p">))</span><span class="o">+</span><span class="s">&#39; radii in &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; seconds&#39;</span>
</div>
<span class="k">def</span> <span class="nf">calcOrderParameterExtra</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">radii</span><span class="p">,</span><span class="n">border</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate extra orderparameters for one simulation. All order parameters are collected and added to a file inpath/id_orderparameter.data.gz. This function expects all data to be gzipped.</span>
<span class="sd">    </span>
<span class="sd">    :param id: simulation identifier</span>
<span class="sd">    :param trange: range of mcs to calculate</span>
<span class="sd">    :param inpath: path containing data files    </span>
<span class="sd">    :param radii: list of radii for wich the order parameter is calculates</span>
<span class="sd">    :param border: remove border pixels from data</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~SimUtils.AnalysisUtils.getOrderParameter`</span>
<span class="sd">    &quot;&quot;&quot;</span>      
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c"># read existing data</span>
    <span class="n">dataE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">inpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_orderparameter.data.gz&#39;</span><span class="p">,</span><span class="n">skiprows</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">inpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_orderparameter.data.gz&#39;</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">trange</span> <span class="o">=</span> <span class="n">dataE</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>    
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">trange</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">radii</span><span class="p">)</span><span class="o">+</span><span class="n">dataE</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">dataE</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">dataE</span>
    <span class="n">co</span> <span class="o">=</span> <span class="n">dataE</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">inpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_orderparameter.data.gz&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>    
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">head</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">radii</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trange</span><span class="p">):</span>
        <span class="c">#~ print t</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">readCellDictFromSigma</span><span class="p">(</span><span class="n">inpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_CF_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="o">+</span><span class="s">&#39;.data.gz&#39;</span><span class="p">,</span><span class="n">inpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_TF_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="o">+</span><span class="s">&#39;.data.gz&#39;</span><span class="p">,</span><span class="n">ignore</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">inpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_CF_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="o">+</span><span class="s">&#39;.data.gz&#39;</span><span class="p">)</span>
        <span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">border</span><span class="p">:</span>
            <span class="n">sigma</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nx</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">sigma</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">sigma</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">ny</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">sigma</span><span class="p">[</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">ny</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c">#~ data[i,0] = t</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">radii</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="n">co</span><span class="p">]</span> <span class="o">=</span> <span class="n">getOrderParameter</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&#39;Order parameter calculated for &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trange</span><span class="p">))</span><span class="o">+</span><span class="s">&#39; and &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">radii</span><span class="p">))</span><span class="o">+</span><span class="s">&#39; radii in &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; seconds&#39;</span>

<span class="c">## Copy simulation data to scratch</span>
<span class="c"># Copy and unpack data in scratch to resume post-processing on cluster.</span>
<span class="c"># @param id simulation identifier</span>
<span class="c"># @param source source folder</span>
<span class="k">def</span> <span class="nf">copyDataBack</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">source</span><span class="p">,</span><span class="n">gunzip</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Copy simulation data back to the scratch drive</span>
<span class="sd">    </span>
<span class="sd">    :param id: simulation id</span>
<span class="sd">    :type id: str</span>
<span class="sd">    :param source: directory with data</span>
<span class="sd">    :type source: str</span>
<span class="sd">    :param gunzip: extract gzipped data</span>
<span class="sd">    :type gunzip: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>    
    <span class="c"># copy data from home to node</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="s">&#39;/scratch/&#39;</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;cp &#39;</span><span class="o">+</span><span class="n">source</span><span class="o">+</span><span class="s">&#39;/data_&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;.tar ./&#39;</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;tar -xf data_&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;.tar&#39;</span><span class="p">)</span>
    <span class="c"># extract gzipped data and move to scratch</span>
    <span class="k">if</span> <span class="n">gunzip</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="s">&#39;/scratch/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;gunzip *.data.gz&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;mv *.data /scratch/&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="s">&#39;/scratch/&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;rm -r &#39;</span><span class="o">+</span><span class="nb">id</span><span class="p">)</span>
    <span class="c"># change working directory to original working directory</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">wd</span><span class="p">)</span>

<span class="c">## Copy simulation data to home</span>
<span class="c"># Copy gzipped simulation data to home before analysis etc.</span>
<span class="c"># @param id simulation identifier</span>
<span class="c"># @param target target folder</span>
<span class="k">def</span> <span class="nf">copyData</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">target</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Gzip data and copy back to home to secure the data before post-processing.</span>
<span class="sd">    </span>
<span class="sd">    :param id: simulation id</span>
<span class="sd">    :param target: directory to copy data to</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>    
    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="s">&#39;/scratch/&#39;</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;cp &#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_*.data &#39;</span><span class="o">+</span><span class="nb">id</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="s">&#39;/scratch/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&#39;gzip -q &#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;*.data&#39;</span>                
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;gzip -q &#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;*.data&#39;</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="s">&#39;/scratch/&#39;</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&#39;tar -cf &#39;</span><span class="o">+</span><span class="n">target</span><span class="o">+</span><span class="s">&#39;/data_&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;.tar &#39;</span><span class="o">+</span><span class="nb">id</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;tar -cf &#39;</span><span class="o">+</span><span class="n">target</span><span class="o">+</span><span class="s">&#39;/data_&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;.tar &#39;</span><span class="o">+</span><span class="nb">id</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;rm -r &#39;</span><span class="o">+</span><span class="nb">id</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">wd</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
    
<span class="c">## Move simulation data to home</span>
<span class="c"># Text data (txt, data) is gzipped and tarred, images are stored in a gzipped tarball.</span>
<span class="c"># @param id simulation identifier</span>
<span class="c"># @param target target folder</span>
<span class="c"># @param data copy .data files to target folder</span>
<span class="c"># @param images copy .png files to target folder</span>
<span class="c"># @param txt copy .txt files to target folder</span>
<span class="k">def</span> <span class="nf">moveData</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">images</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">txt</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Gzip simulation results and copy to home. Different types of data are packed in different ways:</span>
<span class="sd">        </span>
<span class="sd">        * data: all .data files are gzipped and moved to a folder `id`, the folder is tarred on moved to `target`.</span>
<span class="sd">        * images: all .png files are moved to a folder `id`, the folder is gzipped and moved to `target`.</span>
<span class="sd">        * txt: all .txt files are gzipped and moved to a folder `id`, the folder is tarred on moved to `target`.</span>
<span class="sd">    </span>
<span class="sd">    :param id: simulation id</span>
<span class="sd">    :param target: target directory</span>
<span class="sd">    :param data: copy data to target</span>
<span class="sd">    :param images: copy images to target</span>
<span class="sd">    :param txt: copy txt files to target</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="s">&#39;/scratch/&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="nb">id</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>         
        <span class="k">print</span> <span class="s">&#39;gzip -q &#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_*.data&#39;</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;gzip -q &#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_*.data&#39;</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;mv &#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_*.data.gz &#39;</span><span class="o">+</span><span class="nb">id</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;mv &#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_*.data.gz &#39;</span><span class="o">+</span><span class="nb">id</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;tar -cf &#39;</span><span class="o">+</span><span class="n">target</span><span class="o">+</span><span class="s">&#39;/data_&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;.tar &#39;</span><span class="o">+</span><span class="nb">id</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;tar -cf &#39;</span><span class="o">+</span><span class="n">target</span><span class="o">+</span><span class="s">&#39;/data_&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;.tar &#39;</span><span class="o">+</span><span class="nb">id</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;rm -r &#39;</span><span class="o">+</span><span class="nb">id</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">images</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;mv &#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_*.png &#39;</span><span class="o">+</span><span class="nb">id</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;mv &#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_*.png &#39;</span><span class="o">+</span><span class="nb">id</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;tar -zcf &#39;</span><span class="o">+</span><span class="n">target</span><span class="o">+</span><span class="s">&#39;/images_&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;.tar.gz &#39;</span><span class="o">+</span><span class="nb">id</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;tar -zcf &#39;</span><span class="o">+</span><span class="n">target</span><span class="o">+</span><span class="s">&#39;/images_&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;.tar.gz &#39;</span><span class="o">+</span><span class="nb">id</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;rm -r &#39;</span><span class="o">+</span><span class="nb">id</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">txt</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;gzip -q &#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_*.txt&#39;</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;gzip -q &#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_*.txt&#39;</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;mv &#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_*.txt.gz &#39;</span><span class="o">+</span><span class="nb">id</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;mv &#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_*.txt.gz &#39;</span><span class="o">+</span><span class="nb">id</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;tar -cf &#39;</span><span class="o">+</span><span class="n">target</span><span class="o">+</span><span class="s">&#39;/txt_&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;.tar &#39;</span><span class="o">+</span><span class="nb">id</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;tar -cf &#39;</span><span class="o">+</span><span class="n">target</span><span class="o">+</span><span class="s">&#39;/txt_&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;.tar &#39;</span><span class="o">+</span><span class="nb">id</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;rm -r &#39;</span><span class="o">+</span><span class="nb">id</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">wd</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">getPIFfromData</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">inpath</span><span class="p">,</span><span class="n">piffile</span><span class="p">,</span><span class="n">typemap</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Generate PIF from data file</span>
<span class="sd">    </span>
<span class="sd">    :param id: simulation id</span>
<span class="sd">    :param t: simulation time step</span>
<span class="sd">    :param inpath: path to data files</span>
<span class="sd">    :param piffile: file to save pif to</span>
<span class="sd">    :param typemap: map of cell type names and numbers {typeID : typeName}</span>
<span class="sd">    :param gzipped: data is gzipped</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># load cellfield (sigma)</span>
    <span class="n">postfix</span> <span class="o">=</span> <span class="s">&#39;.data&#39;</span>
    <span class="k">if</span> <span class="n">gzipped</span><span class="p">:</span>
        <span class="n">postfix</span> <span class="o">+=</span> <span class="s">&#39;.gz&#39;</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">inpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_CF_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">+</span><span class="n">postfix</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>    
    <span class="n">types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">inpath</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_TF_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">+</span><span class="n">postfix</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
    <span class="c"># open piffile</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">piffile</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="c"># iterate over grid and write pif</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">sigma</span><span class="p">)[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">sigma</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">sigma</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="nb">type</span>  <span class="o">=</span> <span class="n">typemap</span><span class="p">[</span><span class="n">types</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span>
                <span class="c">#~ x = str(sigma.shape[0]-i-1)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="c">#~ y = str(sigma.shape[1]-j-1)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">id</span><span class="p">,</span><span class="nb">type</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">y</span><span class="p">])</span><span class="o">+</span><span class="s">&#39; 0 0</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
                <span class="c">#~ f.write(str(sigma[j][i])+&#39; &#39;+str(typemap[types[j][i]])+&#39; &#39;+str(i)+&#39; &#39;+str(i)+&#39; &#39;+str(j)+&#39; &#39;+str(j)+ &#39; 0 0\n&#39;)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">calculateClusters</span><span class="p">(</span><span class="n">simid</span><span class="p">,</span><span class="n">trange</span><span class="p">,</span><span class="n">indir</span><span class="p">,</span><span class="n">outdir</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">th</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">minlabsize</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">opendisk</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">mincellsize</span><span class="o">=.</span><span class="mi">25</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">border</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate clusters for a simulation.  </span>
<span class="sd">    </span>
<span class="sd">    :param simid: simulation identifier</span>
<span class="sd">    :param trange: list of timesteps</span>
<span class="sd">    :param indir: data directory</span>
<span class="sd">    :param outdir: data to save output to</span>
<span class="sd">    :param r: radius used for the relative director (:func:`~SimUtils.AnalysisUtils.calculateClustersForSim`)</span>
<span class="sd">    :param th: threshold used for the cluster detection algorithm (func:`~SimUtils:AnalysisUtils:getCellClusters`)</span>
<span class="sd">    :param minlabsize: minimum size of an area to be used for cluster detection (func:`~SimUtils:AnalysisUtils:getCellClusters`)</span>
<span class="sd">    :param opendisk: disk size used for opening during cluster detection algorithm (func:`~SimUtils:AnalysisUtils:getCellClusters`)</span>
<span class="sd">    :param mincellsize: minumum fraction of a cell that must bo in a cluster to be added to that cluster func:`~SimUtils:AnalysisUtils:getCellClusters`)</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~SimUtils.CC3DTools.calculateClustersForSim`, :func:`~SimUtils.AnalysisUtils.getRelativeDirField`, :func:`~SimUtils.AnalysisUtils.getCellClusters`, :func:`~SimUtils.AnalysisUtils.calcClusterInterfaces`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">calculateClustersForSim</span><span class="p">([</span><span class="n">simid</span><span class="p">,</span><span class="n">trange</span><span class="p">,</span><span class="n">indir</span><span class="p">,</span><span class="n">outdir</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">th</span><span class="p">,</span><span class="n">minlabsize</span><span class="p">,</span><span class="n">opendisk</span><span class="p">,</span><span class="n">mincellsize</span><span class="p">,</span><span class="n">gzipped</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">saveTrajectories</span><span class="p">(</span><span class="n">simid</span><span class="p">,</span><span class="n">trange</span><span class="p">,</span><span class="n">indir</span><span class="p">,</span><span class="n">outdir</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">border</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">tdict</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">tdict</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">tdict</span> <span class="o">=</span> <span class="n">getTrajectories</span><span class="p">(</span><span class="n">simid</span><span class="p">,</span><span class="n">trange</span><span class="p">,</span><span class="n">indir</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="n">gzipped</span><span class="p">,</span><span class="n">border</span><span class="o">=</span><span class="n">border</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">trange</span><span class="p">),</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">tdict</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">header</span> <span class="o">=</span> <span class="s">&#39;#MCS&#39;</span>
    <span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">trange</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="nb">id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tdict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">data</span><span class="p">[:,</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">tdict</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; X</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; Y&#39;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">outdir</span><span class="o">+</span><span class="n">simid</span><span class="o">+</span><span class="s">&#39;_traj.data&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">header</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">drawTrajectoriesForSim</span><span class="p">(</span><span class="n">simid</span><span class="p">,</span><span class="n">trange</span><span class="p">,</span><span class="n">indir</span><span class="p">,</span><span class="n">outdir</span><span class="p">,</span><span class="n">cmtypes</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">border</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">tdict</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">bg</span><span class="o">=</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">),</span><span class="n">scale</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">fontpath</span><span class="o">=</span><span class="s">&#39;/usr/share/fonts/liberation/LiberationSans-Regular.ttf&#39;</span><span class="p">):</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">readSigma</span><span class="p">(</span><span class="n">simid</span><span class="p">,</span><span class="n">trange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">indir</span><span class="p">,</span><span class="n">gzipped</span><span class="p">,</span><span class="n">border</span><span class="p">)</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="n">readTau</span><span class="p">(</span><span class="n">simid</span><span class="p">,</span><span class="n">trange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">indir</span><span class="p">,</span><span class="n">gzipped</span><span class="p">,</span><span class="n">border</span><span class="p">)</span>
    <span class="n">cm</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="nb">id</span><span class="p">,</span><span class="n">cmtypes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">tau</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sigma</span><span class="o">==</span><span class="nb">id</span><span class="p">)])[</span><span class="mi">0</span><span class="p">]])</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sigma</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">tdict</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">tdict</span> <span class="o">=</span> <span class="n">getTrajectories</span><span class="p">(</span><span class="n">simid</span><span class="p">,</span><span class="n">trange</span><span class="p">,</span><span class="n">indir</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="n">gzipped</span><span class="p">,</span><span class="n">border</span><span class="o">=</span><span class="n">border</span><span class="p">)</span>
    <span class="n">drawTrajectories</span><span class="p">(</span><span class="n">tdict</span><span class="p">,</span><span class="n">outdir</span><span class="o">+</span><span class="n">simid</span><span class="o">+</span><span class="s">&#39;_traj.png&#39;</span><span class="p">,</span><span class="n">cm</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span><span class="n">crop</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">offset</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">bg</span><span class="o">=</span><span class="n">bg</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">getTrajectories</span><span class="p">(</span><span class="n">simid</span><span class="p">,</span><span class="n">trange</span><span class="p">,</span><span class="n">indir</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">border</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate trajactories for all cells in a simulation </span>
<span class="sd">    </span>
<span class="sd">    :param simid: simulation identifier</span>
<span class="sd">    :param trange: list of timesteps</span>
<span class="sd">    :param indir: data directory</span>
<span class="sd">    :param gzipped: set true for gzipped data</span>
<span class="sd">    :param border: set true if data contains a border cell</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~SimUtils.AnalysisUtils.getCoM`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tdict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
    <span class="n">traj</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">_getCOMforT</span><span class="p">,</span> <span class="p">[[</span><span class="n">simid</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">indir</span><span class="p">,</span><span class="n">gzipped</span><span class="p">,</span><span class="n">border</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trange</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trange</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">traj</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;this should not happen&#39;</span>
            <span class="nb">exit</span><span class="p">()</span>
        <span class="k">for</span> <span class="nb">id</span><span class="p">,</span><span class="n">com</span> <span class="ow">in</span> <span class="n">traj</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="n">tdict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">trange</span><span class="p">),</span><span class="mi">2</span><span class="p">)))</span>
            <span class="n">tdict</span><span class="p">[</span><span class="nb">id</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">com</span>
    <span class="k">return</span> <span class="n">tdict</span>

<span class="k">def</span> <span class="nf">_getCOMforT</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="p">[</span><span class="n">simid</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">indir</span><span class="p">,</span><span class="n">gzipped</span><span class="p">,</span><span class="n">border</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span>
    <span class="n">com</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">readSigma</span><span class="p">(</span><span class="n">simid</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">indir</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="n">gzipped</span><span class="p">,</span><span class="n">border</span><span class="o">=</span><span class="n">border</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">com</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">getCoM</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sigma</span><span class="o">==</span><span class="n">i</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">com</span><span class="p">)</span>


    

<span class="c">#~ def calculateClustersForSim(args):</span>
    <span class="c">#~ &quot;&quot;&quot; Function that actually calculates and save data. This function is designed so it works well with the :mod:`multiprocess` module; instead of multiple arguments all arguments are presented in one list. For user convinience, :func:`~SimUtils.CC3DTools.calculateClusters` is created that uses seperate arguments.</span>
    
    <span class="c">#~ &quot;&quot;&quot;</span>
    <span class="c">#~ [simid,trange,indir,outdir,r,th,minlabsize,opendisk,mincellsize,gzipped] = args</span>
    <span class="c">#~ cellTCdict = {}</span>
    <span class="c">#~ for t in trange:</span>
        <span class="c">#~ print simid,t</span>
        <span class="c">#~ sigma = readSigma(simid,t,indir,gzipped=gzipped)</span>
        <span class="c">#~ cells = dict((cell,ClusterCell(cell,np.where(sigma==cell))) for cell in np.unique(sigma[sigma&gt;0]))</span>
        <span class="c">#~ cells = {cell : ClusterCell(cell,np.where(sigma==cell)) for cell in np.unique(sigma[sigma&gt;0])}</span>
        <span class="c">#~ diffield = getRelativeDirField(sigma,cells,r)</span>
        <span class="c">#~ clusters = getCellClusters(diffield,sigma,th,minlabsize,opendisk,mincellsize)</span>
        <span class="c">#~ for id,c in clusters.iteritems():</span>
            <span class="c">#~ for cid in c.cells:</span>
                <span class="c">#~ cells[cid].cluster = id</span>
        <span class="c">#~ calcClusterInterfaces(sigma,clusters,cells)            </span>
        <span class="c">#~ for cid,cell in cells.iteritems():</span>
            <span class="c">#~ if cell.cluster in clusters:</span>
                <span class="c">#~ cluster = clusters[cell.cluster]</span>
            <span class="c">#~ else:</span>
                <span class="c">#~ cluster = None</span>
            <span class="c">#~ cellTCdict.setdefault(cid,ClusterCellTC(cid)).addTimeStep(t,cell.com,cell.l,cluster)        </span>
    <span class="c">#~ sdata = None</span>
    <span class="c">#~ for cid,cellTC in cellTCdict.iteritems():</span>
        <span class="c">#~ savedata = cellTC.getData()   </span>
        <span class="c">#~ if sdata is None:</span>
            <span class="c">#~ sdata = savedata</span>
        <span class="c">#~ else:</span>
            <span class="c">#~ sdata = np.row_stack((sdata,savedata))</span>
        <span class="c">#~ header = cellTC.header        </span>
    <span class="c">#~ fmt = &#39;%d\t%d\t%e\t%e\t%e\t%e\t%e\t%e\t%e\t%e\t%d\t%d\t%d\t%.1f\t%.1f&#39;</span>
    <span class="c">#~ f = open(outdir+simid+&#39;_clusters.data&#39;,&#39;w&#39;)</span>
    <span class="c">#~ f.write(header)</span>
    <span class="c">#~ np.savetxt(f,sdata,fmt=fmt)</span>
    <span class="c">#~ f.close()</span>
    <span class="c">#~ print &#39;saved data for &#39;+simid</span>

<span class="k">def</span> <span class="nf">calcClusters</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">trange</span><span class="p">,</span><span class="n">indir</span><span class="p">,</span><span class="n">outdir</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">th</span><span class="p">,</span><span class="n">minlabsize</span><span class="p">,</span><span class="n">opendisk</span><span class="p">,</span><span class="n">mincellsize</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">border</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Function to call :func:`~SimUtils.CC3DPipeline.getClustersForSim`, needed for compatibility &quot;&quot;&quot;</span>    
    <span class="n">getClustersForSim</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">trange</span><span class="p">,</span><span class="n">indir</span><span class="p">,</span><span class="n">outdir</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">th</span><span class="p">,</span><span class="n">minlabsize</span><span class="p">,</span><span class="n">opendisk</span><span class="p">,</span><span class="n">mincellsize</span><span class="p">,</span><span class="n">gzipped</span><span class="p">,</span><span class="n">border</span><span class="p">)</span>

<div class="viewcode-block" id="getClustersForSim"><a class="viewcode-back" href="../../CC3DPipeline.html#SimUtils.CC3DPipeline.getClustersForSim">[docs]</a><span class="k">def</span> <span class="nf">getClustersForSim</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">trange</span><span class="p">,</span><span class="n">indir</span><span class="p">,</span><span class="n">outdir</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">th</span><span class="p">,</span><span class="n">minlabsize</span><span class="p">,</span><span class="n">opendisk</span><span class="p">,</span><span class="n">mincellsize</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">border</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="n">cellTCdict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trange</span><span class="p">:</span>
        <span class="c">#~ print &#39;find clusters for mcs =&#39;,t</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">readSigma</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">indir</span><span class="p">,</span><span class="n">gzipped</span><span class="o">=</span><span class="n">gzipped</span><span class="p">,</span><span class="n">border</span><span class="o">=</span><span class="n">border</span><span class="p">)</span>
        <span class="c">#~ sigma = readGrid(indir+&#39;/&#39;+id+&#39;/&#39;+id+&#39;_CF_&#39;+str(t)+&#39;.data.gz&#39;)</span>
        <span class="n">diffield</span> <span class="o">=</span> <span class="n">getRelativeDirField</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="c">#~ diffield = np.loadtxt(indir+&#39;/&#39;+id+&#39;/&#39;+id+&#39;_reldir_r=&#39;+str(r)+&#39;_&#39;+str(t)+&#39;.data.gz&#39;)</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">getCellClusters</span><span class="p">(</span><span class="n">diffield</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">th</span><span class="p">,</span><span class="n">minlabsize</span><span class="p">,</span><span class="n">opendisk</span><span class="p">,</span><span class="n">mincellsize</span><span class="p">)</span>            
        <span class="n">cellids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
        <span class="c"># remove ECM (sigma=0) from cellids</span>
        <span class="k">for</span> <span class="n">cid</span><span class="p">,</span><span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="n">csz</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">getClusterSize</span><span class="p">()</span>
            <span class="c"># save data per cells</span>
            <span class="k">for</span> <span class="n">cellid</span> <span class="ow">in</span> <span class="n">cluster</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sigma</span><span class="o">==</span><span class="n">cellid</span><span class="p">)</span>
                <span class="n">cellTCdict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">cellid</span><span class="p">,</span><span class="n">ClusterCellTC</span><span class="p">(</span><span class="n">cellid</span><span class="p">))</span><span class="o">.</span><span class="n">addTimeStep</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">cid</span><span class="p">,</span><span class="n">csz</span><span class="p">)</span> 
                <span class="n">cellids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">cellids</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cellids</span><span class="o">==</span><span class="n">cellid</span><span class="p">))</span>                
        <span class="c"># save data for cells not in a cluster</span>
        <span class="k">for</span> <span class="n">cellid</span> <span class="ow">in</span> <span class="n">cellids</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cellid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sigma</span><span class="o">==</span><span class="n">cellid</span><span class="p">)</span>
            <span class="n">cellTCdict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">cellid</span><span class="p">,</span><span class="n">ClusterCellTC</span><span class="p">(</span><span class="n">cellid</span><span class="p">))</span><span class="o">.</span><span class="n">addTimeStep</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="c"># write data to file per cell</span>
    <span class="k">for</span> <span class="n">cellid</span><span class="p">,</span><span class="n">celltc</span> <span class="ow">in</span> <span class="n">cellTCdict</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">celltc</span><span class="o">.</span><span class="n">time</span><span class="p">,</span><span class="n">calcMSDTransForCellTC</span><span class="p">(</span><span class="n">celltc</span><span class="o">.</span><span class="n">com</span><span class="p">),</span>
                            <span class="n">calcMSDRotForCellTC</span><span class="p">(</span><span class="n">celltc</span><span class="o">.</span><span class="n">laxis</span><span class="p">),</span><span class="n">celltc</span><span class="o">.</span><span class="n">clusterId</span><span class="p">,</span><span class="n">celltc</span><span class="o">.</span><span class="n">clusterSize</span><span class="p">))</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">outdir</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">id</span><span class="o">+</span><span class="s">&#39;_cell_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">cellid</span><span class="p">))</span><span class="o">+</span><span class="s">&#39;_cluster+MSD.data&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;#MCS</span><span class="se">\t</span><span class="s">MSDTrans</span><span class="se">\t</span><span class="s">MSDRot</span><span class="se">\t</span><span class="s">clusterId</span><span class="se">\t</span><span class="s">clusterSize</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span> 
    <span class="k">print</span> <span class="s">&#39;clusters calculated for &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trange</span><span class="p">))</span><span class="o">+</span><span class="s">&#39; morphologies in &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; seconds&#39;</span>
</div>
<div class="viewcode-block" id="createPBSScripts"><a class="viewcode-back" href="../../CC3DPipeline.html#SimUtils.CC3DPipeline.createPBSScripts">[docs]</a><span class="k">def</span> <span class="nf">createPBSScripts</span><span class="p">(</span><span class="n">runid</span><span class="p">,</span><span class="n">joblist</span><span class="p">,</span><span class="n">command</span><span class="p">,</span><span class="n">time</span><span class="p">,</span><span class="n">ncores</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span><span class="n">ppn</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span><span class="n">path</span><span class="o">=</span><span class="s">&#39;batchScripts/&#39;</span><span class="p">,</span><span class="n">xserver</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">python27</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Create a set of PBS scripts to run a simulation on lisa. For each job in joblist a single line command is added to the script:: </span>
<span class="sd">        </span>
<span class="sd">        python command jobid &gt; log/jobid.out 2&gt; log/jobid.err &amp;</span>
<span class="sd">        </span>
<span class="sd">    When the number of commands is equal to ppn, a new PBS script is created.</span>
<span class="sd">    </span>
<span class="sd">    :param runid: identifier for the scripts</span>
<span class="sd">    :param joblist: list of job identifiers</span>
<span class="sd">    :param command: command that runs the simulation</span>
<span class="sd">    :param time: requested walltime on the cluster</span>
<span class="sd">    :param ncores: types of nodes requested (either, 8, 12 or 16)</span>
<span class="sd">    :param ppn: number of processers per node that will be used</span>
<span class="sd">    :param path: location where pbs scripts are saved</span>
<span class="sd">    :param xserver: add lines to pbs script to mimic xserver</span>
<span class="sd">    :param python27: add lines to pbs script to use python 2.7 instead of the default python 2.6</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~SimUtils.CC3DPipeline.createPBS`, :func:`~SimUtils.CC3DPipeline.addCommandToPBS`, :func:`~SimUtils.CC3DPipeline.finishPBS`        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nscripts</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">ppn</span> <span class="o">&gt;</span> <span class="n">ncores</span><span class="p">:</span>
        <span class="n">ppn</span> <span class="o">=</span> <span class="n">ncores</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">jobid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">joblist</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="n">ppn</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nscripts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">finishPBS</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="n">path</span><span class="o">+</span><span class="s">&#39;/run_&#39;</span><span class="o">+</span><span class="n">runid</span><span class="o">+</span><span class="s">&#39;_part_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">nscripts</span><span class="p">)</span>
            <span class="n">createPBS</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="n">time</span><span class="p">,</span><span class="n">ncores</span><span class="p">,</span><span class="n">ppn</span><span class="p">,</span><span class="n">xserver</span><span class="p">,</span><span class="n">python27</span><span class="p">)</span>
            <span class="n">nscripts</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">addCommandToPBS</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="n">command</span><span class="o">+</span><span class="s">&#39; &#39;</span><span class="o">+</span><span class="n">jobid</span><span class="p">,</span><span class="s">&#39;log/&#39;</span><span class="o">+</span><span class="n">jobid</span><span class="p">)</span>
    <span class="n">finishPBS</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
</div>
<span class="k">def</span> <span class="nf">createPBS</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">time</span><span class="p">,</span><span class="n">ncores</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">ppn</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">xserver</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">python27</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Create a set of PBS script, set job settings and add generic commands::</span>
<span class="sd">    </span>
<span class="sd">        #PBS -S /bin/bash</span>
<span class="sd">        #PBS -lnodes=1:ncores:ppn=ppn</span>
<span class="sd">        #PBS -lwalltime=time</span>
<span class="sd">    </span>
<span class="sd">    :param runid: identifier for the scripts</span>
<span class="sd">    :param joblist: list of job identifiers</span>
<span class="sd">    :param command: command that runs the simulation</span>
<span class="sd">    :param time: requested walltime on the cluster</span>
<span class="sd">    :param ncores: types of nodes requested (either, 8, 12 or 16)</span>
<span class="sd">    :param ppn: number of processers per node that will be used</span>
<span class="sd">    :param path: location where pbs scripts are saved</span>
<span class="sd">    :param xserver: add lines to pbs script to mimic xserver</span>
<span class="sd">    :param python27: add lines to pbs script to use python 2.7 instead of the default python 2.6</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;#PBS -S /bin/bash</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;#PBS -lnodes=1&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ncores</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ncores</span> <span class="o">==</span> <span class="mi">12</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ncores</span> <span class="o">==</span> <span class="mi">16</span><span class="p">):</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;:cores&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ncores</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">ppn</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;:ppn=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ppn</span><span class="p">))</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;#PBS -lwalltime=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">xserver</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;export DISPLAY=:1</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;( Xvfb $DISPLAY -auth /dev/null &amp; )</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">python27</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;module load python/2.7.2 </span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;cd $HOME</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">addCommandToPBS</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">command</span><span class="p">,</span><span class="n">log</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Add single line command to existing PBS script:: </span>
<span class="sd">    </span>
<span class="sd">            python command &gt; log.out 2&gt; log/j.err &amp;.     </span>
<span class="sd">        </span>
<span class="sd">    :param filename: path to existing pbs script</span>
<span class="sd">    :param command: complete command (including arguments)</span>
<span class="sd">    :param log: path to and name of log files</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">command</span><span class="o">+</span><span class="s">&#39; &gt; &#39;</span><span class="o">+</span><span class="n">log</span><span class="o">+</span><span class="s">&#39;.out 2&gt; &#39;</span><span class="o">+</span><span class="n">log</span><span class="o">+</span><span class="s">&#39;.err &amp;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">finishPBS</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Finish pbs file &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;wait</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">packScripts</span><span class="p">(</span><span class="n">runid</span><span class="p">,</span><span class="n">simlist</span><span class="p">,</span><span class="n">scriptdir</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="s">&#39;batchScripts&#39;</span><span class="p">):</span>
    <span class="n">cwd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">scriptdir</span><span class="p">)</span>
    <span class="n">command</span> <span class="o">=</span> <span class="s">&#39;tar -cf scripts_&#39;</span><span class="o">+</span><span class="n">runid</span><span class="o">+</span><span class="s">&#39;.tar&#39;</span>
    <span class="k">for</span> <span class="n">sim</span> <span class="ow">in</span> <span class="n">simlist</span><span class="p">:</span>
        <span class="n">command</span> <span class="o">+=</span> <span class="s">&#39; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;.xml&#39;</span>
        <span class="c">#~ command += &#39; &#39;+str(sim)+&#39;-*.xml&#39;</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">cwd</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">target</span><span class="o">+</span><span class="s">&#39;/scripts_&#39;</span><span class="o">+</span><span class="n">runid</span><span class="o">+</span><span class="s">&#39;.tar&#39;</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">target</span><span class="o">+</span><span class="s">&#39;/scripts_&#39;</span><span class="o">+</span><span class="n">runid</span><span class="o">+</span><span class="s">&#39;.tar&#39;</span><span class="p">)</span>
    <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">scriptdir</span><span class="o">+</span><span class="s">&#39;/scripts_&#39;</span><span class="o">+</span><span class="n">runid</span><span class="o">+</span><span class="s">&#39;.tar&#39;</span><span class="p">,</span><span class="n">target</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">packPBS</span><span class="p">(</span><span class="n">runid</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="s">&#39;batchScripts&#39;</span><span class="p">):</span>
    <span class="n">cwd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
    <span class="n">command</span> <span class="o">=</span> <span class="s">&#39;tar -cf jobs_&#39;</span><span class="o">+</span><span class="n">runid</span><span class="o">+</span><span class="s">&#39;.tar run_&#39;</span><span class="o">+</span><span class="n">runid</span><span class="o">+</span><span class="s">&#39;*&#39;</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">cwd</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../CC3DSimUtils.html">MIMB SimUtils 1.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Margriet Palm.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>