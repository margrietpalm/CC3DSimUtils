
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>SimUtils.AnalysisUtils &mdash; OpenSimUtils 1.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="OpenSimUtils 1.0 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../SimUtils.html">OpenSimUtils 1.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for SimUtils.AnalysisUtils</h1><div class="highlight"><pre>
<span class="kn">from</span> <span class="nn">mahotas</span> <span class="kn">import</span> <span class="n">labeled</span>
<span class="kn">from</span> <span class="nn">mahotas</span> <span class="kn">import</span> <span class="n">_convex</span>
<span class="kn">from</span> <span class="nn">mahotas.thin</span> <span class="kn">import</span> <span class="n">thin</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pymorph</span> <span class="kn">as</span> <span class="nn">m</span>
<span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="n">imsave</span><span class="p">,</span><span class="n">imshow</span><span class="p">,</span><span class="n">show</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">Image</span><span class="o">,</span><span class="nn">ImageDraw</span><span class="o">,</span><span class="nn">ImageFont</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">squareform</span><span class="p">,</span><span class="n">pdist</span>

<span class="n">norm</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="n">angle</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>

<div class="viewcode-block" id="Cluster"><a class="viewcode-back" href="../../AnalysisUtils.html#SimUtils.AnalysisUtils.Cluster">[docs]</a><span class="k">class</span> <span class="nc">Cluster</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Container for a cell cluster</span>
<span class="sd">    </span>
<span class="sd">    :param id: cluster id</span>
<span class="sd">    :ivar cells: list of ids of the cells in the clusters</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="nb">id</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cellinterface</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ecminterface</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    
<div class="viewcode-block" id="Cluster.addCell"><a class="viewcode-back" href="../../AnalysisUtils.html#SimUtils.AnalysisUtils.Cluster.addCell">[docs]</a>    <span class="k">def</span> <span class="nf">addCell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cellid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add cell to cluster </span>
<span class="sd">        </span>
<span class="sd">        :param cellid: id of cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cellid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cellid</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Cluster.removeCell"><a class="viewcode-back" href="../../AnalysisUtils.html#SimUtils.AnalysisUtils.Cluster.removeCell">[docs]</a>    <span class="k">def</span> <span class="nf">removeCell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cellid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Remove cell from cluster</span>
<span class="sd">        </span>
<span class="sd">        :param cellid: id of cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cellid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">cellid</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    </div>
<div class="viewcode-block" id="Cluster.getClusterSize"><a class="viewcode-back" href="../../AnalysisUtils.html#SimUtils.AnalysisUtils.Cluster.getClusterSize">[docs]</a>    <span class="k">def</span> <span class="nf">getClusterSize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate number of cell in cluster</span>
<span class="sd">        </span>
<span class="sd">        :return: number of cells in cluster</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#~ print len(self.cells)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">)</span>
</div></div>
<span class="k">def</span> <span class="nf">realconvexhull</span><span class="p">(</span><span class="n">bwimg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Calcuate the real convex hull of an image. The default convex hull algorithms, part of mahotas, returns the coordinates of the pixels on the hull. Therefore, that convex hull intersects with the outer pixels. Here we calculate the hull over a set containing the 4 border points of each pixel.</span>
<span class="sd">    </span>
<span class="sd">    :param bwimg: black-and-white image with 1 for occupied pixels and 0 at empty pixels</span>
<span class="sd">    :type bwimg: numpy array</span>
<span class="sd">    :return: numpy array of points in the hull    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># based on convexhull from mahotas.polygon</span>
    <span class="c"># extra points are added to prevent intersection between the hull and pixel centers</span>
    <span class="n">Y</span><span class="p">,</span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">bwimg</span><span class="p">)</span>
    <span class="n">ye</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">xe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>    
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">xe</span><span class="p">,</span><span class="n">ye</span><span class="p">))</span>
    <span class="n">P</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xe</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span><span class="n">ye</span><span class="p">[</span><span class="n">ind</span><span class="p">]))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">P</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_convex</span><span class="o">.</span><span class="n">convexhull</span><span class="p">(</span><span class="n">P</span><span class="p">))</span><span class="o">/</span><span class="mf">2.0</span>

<div class="viewcode-block" id="getCompactness"><a class="viewcode-back" href="../../AnalysisUtils.html#SimUtils.AnalysisUtils.getCompactness">[docs]</a><span class="k">def</span> <span class="nf">getCompactness</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">minval</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Calculate compactness of a morphology: :math:`\\frac{A_{\\text{area}}}{A_{\\text{convex hull}}}`</span>

<span class="sd">    :param im: image.</span>
<span class="sd">    :type im: numpy array</span>
<span class="sd">    :param minval: minimum value for valid pixels.</span>
<span class="sd">    :type minval: int</span>
<span class="sd">    :return: compactness</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># 1: create negative image</span>
    <span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span>    
    <span class="n">imneg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">im</span><span class="o">&gt;</span><span class="n">minval</span><span class="p">)</span>
    <span class="c"># 2: find borders of negative image, these are all pixels where a neighbor is not cell</span>
    <span class="c">#    thus, all borders are 2 pixels thick! </span>
    <span class="n">bim</span> <span class="o">=</span> <span class="n">labeled</span><span class="o">.</span><span class="n">borders</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imneg</span><span class="p">))</span>    
    <span class="c"># 3: get convex hull with intersection between bim and imneg -&gt; the boundary pixels of the cells</span>
    <span class="c">#    ph is an array of points on the hull</span>
    <span class="c"># Note that the input are only the pixels on the border of the image, thus speeds up the </span>
    <span class="c"># calculations A LOT.</span>
    <span class="n">ph</span> <span class="o">=</span> <span class="n">realconvexhull</span><span class="p">(</span><span class="n">imneg</span><span class="o">&amp;</span><span class="n">bim</span><span class="p">)</span>
    <span class="c"># 4: calculate area of hull according to http://en.wikipedia.org/wiki/Polygon#Area_and_centroid</span>
    <span class="c">#    note that first point on the hull is added to the end for this calculation</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ph</span><span class="p">)</span>
    <span class="n">ph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">ph</span><span class="p">,</span><span class="n">ph</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]))</span>
    <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ph</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">ph</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ph</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">ph</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="c"># return compactness</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">imneg</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="getLCC"><a class="viewcode-back" href="../../AnalysisUtils.html#SimUtils.AnalysisUtils.getLCC">[docs]</a><span class="k">def</span> <span class="nf">getLCC</span><span class="p">(</span><span class="n">im</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Find largest connected component of an image </span>
<span class="sd">    </span>
<span class="sd">    :param im: input image</span>
<span class="sd">    :type im: numpy array</span>
<span class="sd">    :return: image with only largest component</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lab</span><span class="p">,</span><span class="n">nr</span> <span class="o">=</span> <span class="n">labeled</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">lab</span><span class="p">,(</span><span class="n">lab</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">lab</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
    <span class="k">return</span> <span class="n">lab</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sizes</span><span class="o">==</span><span class="nb">max</span><span class="p">(</span><span class="n">sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">)]))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    </div>
<span class="k">def</span> <span class="nf">getNodes</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">closedisk</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">thinloop</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the branchpoints in the image. This is done in a number of steps:</span>
<span class="sd">        </span>
<span class="sd">        1. Prepare image for skeleotanization with a closing operation that closes small holes and removes rough edges.</span>
<span class="sd">        2. Create a skeleton with the thinning method of mahotas.</span>
<span class="sd">        3. Find all the points in the skeleton that have more than 2 first order neighbors in the skeleton.</span>
<span class="sd">        </span>
<span class="sd">    :param im: input image</span>
<span class="sd">    :type im: numpy array    </span>
<span class="sd">    :param closedisk: size of the disk used for closing (step 1).</span>
<span class="sd">    :type closedisk: int</span>
<span class="sd">    :param thinloop: number of thinning iterations (step 2).</span>
<span class="sd">    :type thinloop: int</span>
<span class="sd">    :return: dictionary with nodes: {nodeid : (x,y)}, and skeleton image (nodelist,imout)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c">#--- Make skeleton ---#</span>
    <span class="c"># 1) closing operation to get rid of rough edges</span>
    <span class="n">imout</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">m</span><span class="o">.</span><span class="n">sedisk</span><span class="p">(</span><span class="n">closedisk</span><span class="p">))</span>    
    <span class="c"># 2) acutal thining</span>
    <span class="n">imout</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">thin</span><span class="p">(</span><span class="n">thin</span><span class="p">(</span><span class="n">imout</span><span class="p">),</span> <span class="n">m</span><span class="o">.</span><span class="n">endpoints</span><span class="p">(</span><span class="s">&#39;loop&#39;</span><span class="p">),</span><span class="n">thinloop</span><span class="p">)</span>
    <span class="c"># 3) find branchpoints</span>
    <span class="n">nodedict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">nz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">imout</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nz</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">nz</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">nz</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="n">_getNNeighbors</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">imout</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nb</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">nodedict</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">nodedict</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nodedict</span><span class="p">,</span><span class="n">imout</span>

<span class="k">def</span> <span class="nf">mergeNodesAndEdges</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span><span class="n">d</span><span class="o">=</span><span class="mi">6</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Merge nodes that are too close and redefine the edges for these nodes.</span>

<span class="sd">    :param nodes: dictionary with {nodeid : n(x,y)}.</span>
<span class="sd">    :param edges: list of edges: [(nodeid_source,nodeid_target)].</span>
<span class="sd">    :param d: minimum distance between nodes.</span>
<span class="sd">    :type d: number</span>
<span class="sd">    :return: dictionary with nodes: {nodeid : (x,y)}  and list of edges</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">nnodes</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">nedges</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">squareform</span><span class="p">(</span><span class="n">pdist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">nn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">D</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">d</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nn</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sx</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">sy</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nn</span><span class="p">:</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">sx</span> <span class="o">+=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">sy</span> <span class="o">+=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">newid</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nnodes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">nnodes</span><span class="p">[</span><span class="n">newid</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">sx</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">nn</span><span class="p">)),</span><span class="nb">int</span><span class="p">(</span><span class="n">sy</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">nn</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nn</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nnodes</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">nnodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="n">remedges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">newedges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">nedges</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">nn</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">nn</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">nn</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nn</span><span class="p">):</span>
                        <span class="n">newedges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">newid</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nn</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">nn</span><span class="p">):</span>
                        <span class="n">newedges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">newid</span><span class="p">])</span>
                    <span class="n">remedges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">edge</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">remedges</span><span class="p">:</span>
                <span class="n">nedges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">newedges</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">edge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nedges</span><span class="p">:</span>
                    <span class="n">nedges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nnodes</span><span class="p">,</span><span class="n">nedges</span>
    
<span class="k">def</span> <span class="nf">purgeNodes</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="n">edges</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Remove nodes with only 2 edges.</span>

<span class="sd">    :param nodes: dictionary with {nodeid : n(x,y)}.</span>
<span class="sd">    :param edges: list of edges: [(nodeid_source,nodeid_target)].</span>
<span class="sd">    :return: dictionary with nodes: {nodeid : (x,y)}  and list of edges</span>
<span class="sd">    &quot;&quot;&quot;</span>        
    <span class="n">nnodes</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">nedges</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
    <span class="k">for</span> <span class="nb">id</span><span class="p">,</span><span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="n">degree</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nedges</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>        
        <span class="k">if</span> <span class="nb">id</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">degree</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">degree</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">nnodes</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nedges</span><span class="p">)</span><span class="o">==</span><span class="nb">id</span><span class="p">)</span>
            <span class="n">e0</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">nedges</span><span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]][:])</span>
            <span class="n">e1</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">nedges</span><span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]][:])</span>
            <span class="n">nedges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">nedges</span><span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="o">-</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span><span class="n">nedges</span><span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="o">-</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]])</span>
            <span class="n">nedges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">e0</span><span class="p">)</span>
            <span class="n">nedges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nnodes</span><span class="p">,</span><span class="n">nedges</span>
    
<span class="k">def</span> <span class="nf">getEndPoints</span><span class="p">(</span><span class="n">skel</span><span class="p">,</span><span class="n">nodes</span><span class="p">,</span><span class="n">d</span><span class="o">=</span><span class="mi">6</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the endpoints of a skeleton images. Endpoints are found with an iteration of the following steps:</span>
<span class="sd">    </span>
<span class="sd">        1. Cut a given node N from the graph.</span>
<span class="sd">        2. Label the resulting image to find all the connected components.</span>
<span class="sd">        3. Iterate over the connected components and find the connected components without a node:</span>
<span class="sd">            a. if a connected component has at least one node, an edge is connecting N to the rest of the image; no endpoint;</span>
<span class="sd">            b. if a connected component has no nodes, it may be an edge to an endpoint.</span>
<span class="sd">        4. For a connected component without nodes: check if there is a pixel in the neighbor that has only 1 first order neighbor and is further away than d.</span>
<span class="sd">        5. One, or more endpoints can be found for each connected component, only save the endpoint that is farthest away from node N`.</span>
<span class="sd">    </span>
<span class="sd">    :param skel: skeleton image</span>
<span class="sd">    :type skel: numpy array</span>
<span class="sd">    :param nodes: dictionary with {nodeid : (x,y)}</span>
<span class="sd">    :param d: minimal distance between two branchpoints (4).</span>
<span class="sd">    :type d: number</span>
<span class="sd">    :return: list of endpoint positions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">im</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">skel</span><span class="p">)</span>
    <span class="n">nof</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">endpoints</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nof</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">nid</span><span class="p">,</span><span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
        <span class="n">_delNode</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">w</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>    
        <span class="n">lab</span><span class="p">,</span><span class="n">nr</span> <span class="o">=</span> <span class="n">labeled</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nr</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">noNodes</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">labim</span> <span class="o">=</span> <span class="n">lab</span><span class="o">==</span><span class="n">i</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">labim</span><span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">noNodes</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">noNodes</span><span class="p">:</span>
                <span class="n">nof</span> <span class="o">+=</span> <span class="mi">1</span>                
                <span class="n">ep</span> <span class="o">=</span> <span class="n">_findEndPoint</span><span class="p">(</span><span class="n">labim</span><span class="p">,</span><span class="n">nodes</span><span class="p">,</span><span class="n">d</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">ep</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ep</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ep</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">dx</span><span class="p">:</span>
                            <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                            <span class="n">idx</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ep</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">endpoints</span>

<span class="k">def</span> <span class="nf">_findEndPoint</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">nodes</span><span class="p">,</span><span class="n">d</span><span class="o">=</span><span class="mi">6</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Find end points in an image. End points are defined as pixels with only 1 first order neighbor. This function is used by getEndPoints and is not intended for direct use. &quot;&quot;&quot;</span>
    <span class="n">nz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">im</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>    
    <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nz</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">nz</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">nz</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="n">_getNNeighbors</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">im</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nb</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">isNode</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">):</span>                    
                    <span class="n">isNode</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isNode</span><span class="p">:</span>
                <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">points</span>

<span class="k">def</span> <span class="nf">getBlobs</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">minsize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">opendisk</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Find blobs in an image. </span>
<span class="sd">    </span>
<span class="sd">    :param im: input image</span>
<span class="sd">    :type im: numpy array</span>
<span class="sd">    :param minsize: minimal size of detected blobs</span>
<span class="sd">    :type minsize: int</span>
<span class="sd">    :param opendisk: disk size for opening operation (ommitted when opendisk &lt;= 0)</span>
<span class="sd">    :type opendisk: int</span>
<span class="sd">    :return: identifiers for areas with blobs &gt; minsize and labeled image (lac,lab)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">opendisk</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span><span class="n">m</span><span class="o">.</span><span class="n">sedisk</span><span class="p">(</span><span class="n">opendisk</span><span class="p">))</span>  
    <span class="c">#~ n = np.array([[1,1,1],[1,1,1],[1,1,1]])    </span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
    <span class="n">lab</span><span class="p">,</span><span class="n">nr</span> <span class="o">=</span> <span class="n">labeled</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">lab</span><span class="p">,(</span><span class="n">lab</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">lab</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
    <span class="n">lac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">sizes</span><span class="o">&gt;</span><span class="n">minsize</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">lac</span><span class="p">,</span><span class="n">lab</span>

<span class="k">def</span> <span class="nf">getMeshes</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">minsize</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Find meshes (white areas) in an image. </span>
<span class="sd">    </span>
<span class="sd">    :param im: input image</span>
<span class="sd">    :type im: numpy array    </span>
<span class="sd">    :param minsize: minimal size of detected meshes</span>
<span class="sd">    :type minsize: int</span>
<span class="sd">    :return: list of mesh sizes</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">lab</span><span class="p">,</span><span class="n">nr</span> <span class="o">=</span> <span class="n">labeled</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">im</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">lab</span><span class="p">,(</span><span class="n">lab</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">lab</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
    <span class="c"># we are looking at white areas, this also includes the area around the image (this will be label=0)</span>
    <span class="n">lac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">nr</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">minsize</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">sizes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lac</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">lac</span><span class="p">)]]</span>

<span class="k">def</span> <span class="nf">getEdges</span><span class="p">(</span><span class="n">nodedict</span><span class="p">,</span><span class="n">skel</span><span class="p">,</span><span class="n">w</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Find edges that connect the nodes in a skeleton. Edges are detected per node N with the following steps:</span>
<span class="sd">    </span>
<span class="sd">        1. Add N to the skeleton and remove all other nodes;</span>
<span class="sd">        2. Label image and continue with subimage that contains N;</span>
<span class="sd">        3. All nodes that intersect with the image from (2) are connected to N;</span>
<span class="sd">    </span>
<span class="sd">    :param nodedict: dictionary with {nodeid : (x,y)}</span>
<span class="sd">    :param skel: skeleton image</span>
<span class="sd">    :type skel: numpy array    </span>
<span class="sd">    :param w: node width that will be cut out of the first image</span>
<span class="sd">    :type w: int</span>
<span class="sd">    :returns: list of edges, values correspond with indices of nodelist</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c"># node id is position in list</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c">#~ for i,node in enumerate(nodelist):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">node</span> <span class="ow">in</span> <span class="n">nodedict</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="n">connected</span> <span class="o">=</span> <span class="n">_getEdgesForNode</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">nodedict</span><span class="p">,</span><span class="n">skel</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">connected</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">nd</span><span class="p">]</span>
            <span class="n">e</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">connected</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">edges</span>


<span class="k">def</span> <span class="nf">getNofEdges</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="n">skel</span><span class="p">,</span><span class="n">w</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Find number of edges for each node in nodelist. </span>
<span class="sd">    </span>
<span class="sd">    :param nodes: dictionary with {nodeid : (x,y)}</span>
<span class="sd">    :param skel: skeleton image</span>
<span class="sd">    :type skel: numpy array    </span>
<span class="sd">    :param w: node width that will be cut out of the first image</span>
<span class="sd">    :type w: int    </span>
<span class="sd">    :returns: dict with index of nodelist and number of edges</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">_getNofEdgesForNode</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">nodes</span><span class="p">,</span><span class="n">skel</span><span class="p">,</span><span class="n">w</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="o">.</span><span class="n">iteritems</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">_getNofEdgesForNode</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="n">nodes</span><span class="p">,</span><span class="n">skel</span><span class="p">,</span><span class="n">w</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Collect all edges for a single node. This function is not intended for usage from outside but is called by getEdges &quot;&quot;&quot;</span>
    <span class="c"># 1) create image of skeleton with node</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">skel</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">idx</span><span class="p">:</span>
            <span class="n">_delNode</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
    <span class="n">_addNode</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">nodes</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span><span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
    <span class="c"># 2) label image </span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
    <span class="n">lab</span><span class="p">,</span><span class="n">nr</span> <span class="o">=</span> <span class="n">labeled</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>    
    <span class="n">nodeim</span> <span class="o">=</span> <span class="n">lab</span><span class="o">==</span><span class="n">lab</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">nodes</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
    <span class="c"># 3) remove node from image</span>
    <span class="n">_delNode</span><span class="p">(</span><span class="n">nodeim</span><span class="p">,</span><span class="n">nodes</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span><span class="n">w</span><span class="p">)</span>
    <span class="c"># 4) label image</span>
    <span class="n">lab</span><span class="p">,</span><span class="n">nr</span> <span class="o">=</span> <span class="n">labeled</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">nodeim</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nr</span>

<span class="k">def</span> <span class="nf">_getEdgesForNode</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="n">nodedict</span><span class="p">,</span><span class="n">skel</span><span class="p">,</span><span class="n">w</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Collect all edges for a single node. This function is not intended for usage from outside but is called by getEdges &quot;&quot;&quot;</span>
    <span class="c">#~ print idx</span>
    <span class="c"># 1) create image of skeleton with node</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">skel</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">node</span> <span class="ow">in</span> <span class="n">nodedict</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">idx</span><span class="p">:</span>
            <span class="n">_delNode</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
    <span class="n">_addNode</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">nodedict</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span><span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
    <span class="c">#~ imshow(im)</span>
    <span class="c">#~ show()</span>
    <span class="c"># 2) label image </span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
    <span class="n">lab</span><span class="p">,</span><span class="n">nr</span> <span class="o">=</span> <span class="n">labeled</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>    
    <span class="n">nodeim</span> <span class="o">=</span> <span class="n">lab</span><span class="o">==</span><span class="n">lab</span><span class="p">[</span><span class="n">nodedict</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">nodedict</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
    <span class="c">#~ imshow(nodeim)</span>
    <span class="c">#~ show()    </span>
    <span class="c"># 3) put nodes on labeled image with node idx and label again</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">node</span> <span class="ow">in</span> <span class="n">nodedict</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">idx</span><span class="p">:</span>
            <span class="n">_addNode</span><span class="p">(</span><span class="n">nodeim</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
    <span class="c"># 4) find nodes in nodelist that are in labeled image with idx</span>
    <span class="n">lab</span><span class="p">,</span><span class="n">nr</span> <span class="o">=</span> <span class="n">labeled</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">nodeim</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="n">connim</span> <span class="o">=</span> <span class="n">lab</span><span class="o">==</span><span class="n">lab</span><span class="p">[</span><span class="n">nodedict</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">nodedict</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
    <span class="c">#~ imshow(connim)</span>
    <span class="c">#~ show()    </span>
    <span class="n">conn</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">node</span> <span class="ow">in</span> <span class="n">nodedict</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">idx</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">connim</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">conn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">conn</span>

<span class="k">def</span> <span class="nf">_addNode</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span><span class="n">w</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="c"># represent node as 3x3 block    </span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>    
    <span class="n">ny</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">j</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>    
    <span class="c">#~ ny = pos[1]+np.array([-1,0,1,-1,1,0,-1,0,1])</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nx</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nx</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">&lt;</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ny</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ny</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">&lt;</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]]</span>    
    <span class="n">im</span><span class="p">[</span><span class="n">nx</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span><span class="n">ny</span><span class="p">[</span><span class="n">pos</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
    
<span class="k">def</span> <span class="nf">_delNode</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span><span class="n">w</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="c"># represent node as 3x3 block    </span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>    
    <span class="n">ny</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">j</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>    
    <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nx</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nx</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">&lt;</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ny</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ny</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">&lt;</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]]</span>    
    <span class="n">im</span><span class="p">[</span><span class="n">nx</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span><span class="n">ny</span><span class="p">[</span><span class="n">pos</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span> 

<span class="k">def</span> <span class="nf">_getNNeighbors</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">im</span><span class="p">):</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nx</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nx</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">&lt;</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ny</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ny</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">&lt;</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">im</span><span class="p">[</span><span class="n">nx</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span><span class="n">ny</span><span class="p">[</span><span class="n">pos</span><span class="p">]])</span>

<span class="k">def</span> <span class="nf">_getNNeighbors2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">im</span><span class="p">):</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nx</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nx</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">&lt;</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ny</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ny</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">&lt;</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">im</span><span class="p">[</span><span class="n">nx</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span><span class="n">ny</span><span class="p">[</span><span class="n">pos</span><span class="p">]])</span>

<div class="viewcode-block" id="getDirector"><a class="viewcode-back" href="../../AnalysisUtils.html#SimUtils.AnalysisUtils.getDirector">[docs]</a><span class="k">def</span> <span class="nf">getDirector</span><span class="p">(</span><span class="n">com</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">cells</span><span class="p">,</span><span class="n">weighted</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Find the director of the center of mass of a cell. </span>
<span class="sd">    </span>
<span class="sd">    This implementation is best when the director is only calculated per cell, as done for the calculation of the order parameter. When the director is calculated per pixel use getDirectorPF.  </span>
<span class="sd">    </span>
<span class="sd">    :param com: center of mass of the cell [x,y]</span>
<span class="sd">    :param r: radius of neighborhood</span>
<span class="sd">    :type r: int</span>
<span class="sd">    :param sigma: CPM grid</span>
<span class="sd">    :type sigma: numpy array</span>
<span class="sd">    :param cells: dictionary with cell id&#39;s as keys and :class:`~SimUtils.Cell.Cell` instances as values</span>
<span class="sd">    :type cells: dict</span>
<span class="sd">    :param weighted: average over cells (weighted=False) or over pixels (weighted=True)</span>
<span class="sd">    :return: director (degrees)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Cut part we need out of sigma and create x- and y-grid in this range</span>
    <span class="n">xmin</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">))</span>
    <span class="n">xmax</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">r</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">r</span><span class="p">))</span>
    <span class="n">ymin</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">))</span>
    <span class="n">ymax</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">r</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">r</span><span class="p">))</span>        
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">[</span><span class="n">xmin</span><span class="p">:</span><span class="n">xmax</span><span class="p">,</span><span class="n">ymin</span><span class="p">:</span><span class="n">ymax</span><span class="p">]</span>
    <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">xmin</span><span class="p">:</span><span class="n">xmax</span><span class="p">,</span><span class="n">ymin</span><span class="p">:</span><span class="n">ymax</span><span class="p">]</span>
    <span class="c"># calculate distances on the grid to find pixels within the circle</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">neighborhood</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">d</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">])</span>
    <span class="n">neighborhood</span> <span class="o">=</span> <span class="n">neighborhood</span><span class="p">[</span><span class="n">neighborhood</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
    <span class="c"># calculate average angle</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">weighted</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">d</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">neighborhood</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">neighborhood</span><span class="p">)))</span>
    <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">neighborhood</span><span class="p">:</span>
        <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span><span class="o">.</span><span class="n">getAngle</span><span class="p">())</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">a</span><span class="p">[</span><span class="n">a</span><span class="o">&gt;</span><span class="mi">90</span><span class="p">]</span> <span class="o">=</span> <span class="mi">180</span><span class="o">-</span><span class="n">a</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
    
<span class="c">## Find the director of the com of a cell.</span></div>
<span class="k">def</span> <span class="nf">getDirectorPF</span><span class="p">(</span><span class="n">com</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">angles</span><span class="p">,</span><span class="n">weighted</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Find the director of the center of mass of a cell. </span>
<span class="sd">    </span>
<span class="sd">    This implementation is faster (for some reason) if the director for every pixel is calculated, if the director per cell is calculated use getDirector.</span>
<span class="sd">    </span>
<span class="sd">    :param com: center of mass of the cell</span>
<span class="sd">    :param r: radius of neighborhood</span>
<span class="sd">    :param sigma: CPM grid</span>
<span class="sd">    :type sigma: numpy array</span>
<span class="sd">    :param angles: cell angle (degrees) at every coordinate (-1 for medium)</span>
<span class="sd">    :type angles: numpy array</span>
<span class="sd">    :param weighted: average over cells (weighted=False) or over pixels (weighted=True)</span>
<span class="sd">    :return: director (degrees)    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c"># Cut part we need out of sigma and create x- and y-grid in this range</span>
    <span class="n">xmin</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">))</span>
    <span class="n">xmax</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">r</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">r</span><span class="p">))</span>
    <span class="n">ymin</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">r</span><span class="p">))</span>
    <span class="n">ymax</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">r</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">r</span><span class="p">))</span>        
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">[</span><span class="n">xmin</span><span class="p">:</span><span class="n">xmax</span><span class="p">,</span><span class="n">ymin</span><span class="p">:</span><span class="n">ymax</span><span class="p">]</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="n">xmin</span><span class="p">:</span><span class="n">xmax</span><span class="p">,</span><span class="n">ymin</span><span class="p">:</span><span class="n">ymax</span><span class="p">]</span>
    <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">xmin</span><span class="p">:</span><span class="n">xmax</span><span class="p">,</span><span class="n">ymin</span><span class="p">:</span><span class="n">ymax</span><span class="p">]</span>
    <span class="c"># calculate distances on the grid to find pixels within the circle</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">sa</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">[</span><span class="n">d</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="n">d</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">]</span>
    <span class="n">an</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">sa</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>    
    <span class="k">if</span> <span class="n">weighted</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">an</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">an</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">an</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">an</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sa</span><span class="o">==</span><span class="n">cid</span><span class="p">)][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sa</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sa</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)])])</span>      

<span class="c"># http://en.wikipedia.org/wiki/Liquid_crystal#Order_parameter</span>
<span class="k">def</span> <span class="nf">getOrderParameter</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">weighted</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate order parameter for a morphology. Based on the given radius the order parameters is either calculated locally :func:`~SimUtils.AnalysisUtils.getLocalOrderParameter` or globally :func:`~SimUtils.AnalysisUtils.getGlobalOrderParameter`.</span>
<span class="sd">    </span>
<span class="sd">    :param cells: cell objects</span>
<span class="sd">    :type cells: dict</span>
<span class="sd">    :param sigma: CPM grid</span>
<span class="sd">    :type sigma: numpy array</span>
<span class="sd">    :param r: radius of neighborhood    </span>
<span class="sd">    :type r: int</span>
<span class="sd">    :param weighted: average over cells (weighted=False) or over pixels (weighted=True)</span>
<span class="sd">    :type weighted: bool</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~SimUtils.AnalysisUtils.getLocalOrderParameter`, :func:`~SimUtils.AnalysisUtils.getGlobalOrderParameter`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">rmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nx</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">ny</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">rmax</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">getLocalOrderParameter</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">weighted</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c">#~ print &#39;calculate global&#39;</span>
        <span class="k">return</span> <span class="n">getGlobalOrderParameter</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">weighted</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<div class="viewcode-block" id="getOrderParameterFromGrid"><a class="viewcode-back" href="../../AnalysisUtils.html#SimUtils.AnalysisUtils.getOrderParameterFromGrid">[docs]</a><span class="k">def</span> <span class="nf">getOrderParameterFromGrid</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">angles</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">weighted</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate order parameter for a morphology using the cpm grid data. Based on the given radius the order parameters is either calculated locally :func:`~SimUtils.AnalysisUtils.getLocalOrderParameter` or globally :func:`~SimUtils.AnalysisUtils.getGlobalOrderParameter`.</span>
<span class="sd">    </span>
<span class="sd">    :param sigma: CPM grid</span>
<span class="sd">    :type sigma: numpy array</span>
<span class="sd">    :param angles: array of cell angles</span>
<span class="sd">    :type angles: numpy array    </span>
<span class="sd">    :param r: radius of neighborhood    </span>
<span class="sd">    :type r: int</span>
<span class="sd">    :param weighted: average over cells (weighted=False) or over pixels (weighted=True)</span>
<span class="sd">    :type weighted: bool</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~SimUtils.AnalysisUtils.getLocalOrderParameterFromGrid`, :func:`~SimUtils.AnalysisUtils.getGlobalOrderParameterFromGrid`</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nx</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">ny</span><span class="o">**</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">getLocalOrderParameterFromGrid</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">angles</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">weighted</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">getGlobalOrderParameterFromGrid</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">angles</span><span class="p">,</span><span class="n">weighted</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="getLocalOrderParameterFromGrid"><a class="viewcode-back" href="../../AnalysisUtils.html#SimUtils.AnalysisUtils.getLocalOrderParameterFromGrid">[docs]</a><span class="k">def</span> <span class="nf">getLocalOrderParameterFromGrid</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">angles</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">weighted</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate local order parameter for a morphology using data from the cpm grid.</span>
<span class="sd">    </span>
<span class="sd">    :param sigma: CPM grid</span>
<span class="sd">    :type sigma: numpy array</span>
<span class="sd">    :param angles: array of cell angles</span>
<span class="sd">    :type angles: numpy array  </span>
<span class="sd">    :param r: radius of neighborhood    </span>
<span class="sd">    :type r: radius of neighborhood</span>
<span class="sd">    :param weighted: average over cells (weighted=False) or over pixels (weighted=True)    </span>
<span class="sd">    :type weighted: bool    </span>
<span class="sd">    :return: local order parameter</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~SimUtils.AnalysisUtils.getDirector`</span>
<span class="sd">    &quot;&quot;&quot;</span>     
    <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sigma</span><span class="o">==</span><span class="nb">id</span><span class="p">)][</span><span class="mi">0</span><span class="p">]</span>
        <span class="c">#~ print np.min(a),np.max(a)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">getDirectorPF</span><span class="p">(</span><span class="n">getCoM</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sigma</span><span class="o">==</span><span class="nb">id</span><span class="p">)),</span><span class="n">r</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">angles</span><span class="p">,</span><span class="n">weighted</span><span class="o">=</span><span class="n">weighted</span><span class="p">)</span>        
        <span class="c">#~ print np.min(A),np.max(A)</span>
        <span class="c">#~ dA = abs(a-A) if abs(a-A) &lt; 90 else 180-abs(a-A)</span>
        <span class="n">dA</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">A</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">A</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">A</span><span class="p">)</span>
        <span class="c">#~ s += (3*np.power(np.cos((2*np.pi*dA)/360.0),2)-1)/2.0</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dA</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">/</span><span class="n">n</span>
</div>
<div class="viewcode-block" id="getGlobalOrderParameterFromGrid"><a class="viewcode-back" href="../../AnalysisUtils.html#SimUtils.AnalysisUtils.getGlobalOrderParameterFromGrid">[docs]</a><span class="k">def</span> <span class="nf">getGlobalOrderParameterFromGrid</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">angles</span><span class="p">,</span><span class="n">weighted</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate local order parameter for a morphology using data from the cpm grid.</span>
<span class="sd">    </span>
<span class="sd">    :param sigma: CPM grid</span>
<span class="sd">    :type sigma: numpy array</span>
<span class="sd">    :param angles: array of cell angles</span>
<span class="sd">    :type angles: numpy array </span>
<span class="sd">    :param weighted: average over cells (weighted=False) or over pixels (weighted=True)    </span>
<span class="sd">    :type weighted: bool    </span>
<span class="sd">    :return: global order parameter    </span>
<span class="sd">    &quot;&quot;&quot;</span>      
    <span class="k">if</span> <span class="n">weighted</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sigma</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sigma</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)])</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">dA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">A</span><span class="p">)</span>
    <span class="n">dA</span><span class="p">[</span><span class="n">dA</span> <span class="o">&gt;</span> <span class="o">.</span><span class="mi">5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dA</span><span class="p">[</span><span class="n">dA</span> <span class="o">&gt;</span> <span class="o">.</span><span class="mi">5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">]</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dA</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="c">#~ return np.mean((3*np.power(np.cos((2*np.pi*dA)/360.0),2)-1)/2.0)</span>
    

<span class="c"># http://en.wikipedia.org/wiki/Liquid_crystal#Order_parameter</span></div>
<span class="k">def</span> <span class="nf">getLocalOrderParameter</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">weighted</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate local order parameter for a morphology</span>
<span class="sd">    </span>
<span class="sd">    :param cells: cell objects</span>
<span class="sd">    :type cells: dict</span>
<span class="sd">    :param sigma: CPM grid</span>
<span class="sd">    :type sigma: numpy array</span>
<span class="sd">    :param r: radius of neighborhood    </span>
<span class="sd">    :type r: int</span>
<span class="sd">    :param weighted: average over cells (weighted=False) or over pixels (weighted=True)    </span>
<span class="sd">    :type weighted: bool    </span>
<span class="sd">    :return: local order parameter</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~SimUtils.AnalysisUtils.getDirector`</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">adict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="nb">id</span><span class="p">,</span><span class="n">cell</span><span class="o">.</span><span class="n">getAngle</span><span class="p">())</span> <span class="k">for</span> <span class="nb">id</span><span class="p">,</span><span class="n">cell</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">iteritems</span><span class="p">())</span>
    <span class="k">for</span> <span class="nb">id</span><span class="p">,</span><span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">sigma</span><span class="p">:</span>
            <span class="n">angles</span><span class="p">[</span><span class="n">sigma</span><span class="o">==</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">adict</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span>   
    <span class="k">for</span> <span class="nb">id</span><span class="p">,</span><span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">adict</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">-</span><span class="mi">180</span>
        <span class="c">#~ A = getDirector(cell.getCoM(),r,sigma,cells,weighted)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">getDirectorPF</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">getCoM</span><span class="p">(),</span><span class="n">r</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">cells</span><span class="p">,</span><span class="n">angles</span><span class="p">,</span><span class="n">weighted</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>        
        <span class="n">dA</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">A</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">A</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">90</span> <span class="k">else</span> <span class="mi">180</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">A</span><span class="p">)</span>
        <span class="c">#~ print a,A,dA</span>
        <span class="c">#~ print (2*np.pi*dA)/360.0</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">dA</span><span class="p">)</span><span class="o">/</span><span class="mf">360.0</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">/</span><span class="n">n</span>
    
  

<span class="c"># http://en.wikipedia.org/wiki/Liquid_crystal#Order_parameter</span>
<span class="k">def</span> <span class="nf">getGlobalOrderParameter</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">weighted</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate local order parameter for a morphology</span>
<span class="sd">    </span>
<span class="sd">    :param cells: cell objects</span>
<span class="sd">    :type cells: dict</span>
<span class="sd">    :param sigma: CPM grid</span>
<span class="sd">    :type sigma: numpy array</span>
<span class="sd">    :param weighted: average over cells (weighted=False) or over pixels (weighted=True)    </span>
<span class="sd">    :type weighted: bool    </span>
<span class="sd">    :return: global order parameter    </span>
<span class="sd">    &quot;&quot;&quot;</span>       
    <span class="k">if</span> <span class="n">weighted</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="nb">id</span><span class="p">,</span><span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">sigma</span><span class="p">:</span>
                <span class="n">a</span><span class="p">[</span><span class="n">sigma</span><span class="o">==</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">getAngle</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="nb">id</span><span class="p">,</span><span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">sigma</span><span class="p">:</span>
                <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">getAngle</span><span class="p">())</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>        
    <span class="n">a</span><span class="p">[</span><span class="n">a</span><span class="o">&gt;</span><span class="mi">90</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">a</span><span class="o">&gt;</span><span class="mi">90</span><span class="p">]</span><span class="o">-</span><span class="mi">180</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">dA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">A</span><span class="p">)</span>
    <span class="n">dA</span><span class="p">[</span><span class="n">dA</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dA</span><span class="p">[</span><span class="n">dA</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">]</span><span class="o">-</span><span class="mi">180</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">dA</span><span class="p">)</span><span class="o">/</span><span class="mf">360.0</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
    

<div class="viewcode-block" id="getCellAngle"><a class="viewcode-back" href="../../AnalysisUtils.html#SimUtils.AnalysisUtils.getCellAngle">[docs]</a><span class="k">def</span> <span class="nf">getCellAngle</span><span class="p">(</span><span class="n">pix</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate angle of a cell on interval :math:`[0,\pi]`</span>
<span class="sd">    </span>
<span class="sd">    :param pix: cell coordinates ([x1,...,xn],[y1,...,yn])</span>
<span class="sd">    :return: angle in radians on interval :math:`[0,\pi]`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">getCellOrientation</span><span class="p">(</span><span class="n">pix</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">a</span>
</div>
<span class="k">def</span> <span class="nf">getCellAngleFromOrientation</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate angle of a cell using the cell orientation on interval :math:`[0,\pi]`</span>
<span class="sd">    </span>
<span class="sd">    :param l: cell orientation [x,y]</span>
<span class="sd">    :return: angle in radians on interval :math:`[0,\pi]`</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c">#~ if a &lt; 1:</span>
        <span class="n">a</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">a</span>

<span class="k">def</span> <span class="nf">getCoM</span><span class="p">(</span><span class="n">pix</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate center of mass of a cell </span>
<span class="sd">    </span>
<span class="sd">    :param pix: cell coordinates ([x1,...,xn],[y1,...,yn])</span>
<span class="sd">    :return: center of mass (x,y)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">cx</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pix</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">cy</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pix</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">pix</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">cx</span><span class="p">,</span><span class="n">cy</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">getLargestCellComponent</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">cellid</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Identify connected components of a cell and return the pixels for the largest connected component.</span>
<span class="sd">    </span>
<span class="sd">    :param sigma: CPM grid</span>
<span class="sd">    :type sigma: numpy array</span>
<span class="sd">    :param cellid: cell identifier</span>
<span class="sd">    :type cellid: int</span>
<span class="sd">    :return: tuple with lists of x and y pixels of the largest component</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">imBW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">sigma</span><span class="o">==</span><span class="n">cellid</span><span class="p">)</span>    
    <span class="n">se</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>      
    <span class="n">lab</span><span class="p">,</span><span class="n">nr</span> <span class="o">=</span> <span class="n">labeled</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">imBW</span><span class="p">,</span><span class="n">Bc</span><span class="o">=</span><span class="n">se</span><span class="p">)</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">lab</span><span class="p">,(</span><span class="n">lab</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">lab</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
    <span class="n">lidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sizes</span><span class="o">==</span><span class="nb">max</span><span class="p">(</span><span class="n">sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">)]))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lab</span><span class="o">==</span><span class="n">lidx</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">getCellInertiaTensor</span><span class="p">(</span><span class="n">pix</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get inertia tensor for a cell </span>
<span class="sd">    </span>
<span class="sd">    :param pix: cell coordinates ([x1,...,xn],[y1,...,yn])</span>
<span class="sd">    :return: inertia tensor [[Ixx,Ixy],[Ixy,Iyy]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">cx</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pix</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">cy</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pix</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Ixx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">pix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">cx</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">Iyy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">pix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">cy</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">Ixy</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">pix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">cx</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">pix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">cy</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">Ixx</span><span class="p">,</span><span class="n">Ixy</span><span class="p">],[</span><span class="n">Ixy</span><span class="p">,</span><span class="n">Iyy</span><span class="p">]])</span>

<span class="k">def</span> <span class="nf">getCellAreas</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate areas of cells.</span>
<span class="sd">    </span>
<span class="sd">    :param sigma: CPM grid</span>
<span class="sd">    :type sigma: numpy array</span>
<span class="sd">    :return: list of cell areas</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sigma</span><span class="o">==</span><span class="n">cid</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">getCellLengths</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate length of each cell.</span>
<span class="sd">    </span>
<span class="sd">    :param sigma: CPM grid</span>
<span class="sd">    :type sigma: numpy array</span>
<span class="sd">    :return: list of cell length</span>
<span class="sd">    &quot;&quot;&quot;</span>      
    <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>        
        <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">getCellLength</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sigma</span><span class="o">==</span><span class="n">cid</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">getCellComponents</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get all connected components of cells.</span>
<span class="sd">    </span>
<span class="sd">    :param sigma: CPM grid</span>
<span class="sd">    :type sigma: numpy array</span>
<span class="sd">    :return: list of connected components</span>
<span class="sd">    &quot;&quot;&quot;</span>        
    <span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>    
        <span class="p">[</span><span class="n">lac</span><span class="p">,</span><span class="n">lab</span><span class="p">]</span> <span class="o">=</span> <span class="n">getBlobs</span><span class="p">(</span><span class="n">sigma</span><span class="o">==</span><span class="n">cid</span><span class="p">,</span><span class="n">minsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lac</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">getCellLength</span><span class="p">(</span><span class="n">pix</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate length of a cell using the inertia tensor.</span>
<span class="sd">    </span>
<span class="sd">    :param pix: cell coordinates ([x1,...,xn],[y1,...,yn])</span>
<span class="sd">    :return: cell length</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~SimUtils.AnalysisUtils.getCellInertiaTensor`    </span>
<span class="sd">    &quot;&quot;&quot;</span>        
    <span class="n">a</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>    
    <span class="p">[</span><span class="n">V</span><span class="p">,</span><span class="n">D</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">getCellInertiaTensor</span><span class="p">(</span><span class="n">pix</span><span class="p">))</span>
    <span class="k">return</span> <span class="mf">4.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">V</span><span class="p">))</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">getCellOrientation</span><span class="p">(</span><span class="n">pix</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate orientation of a cell. The orientation is the eigenvector corresponding to the largest eigenvalue of the cells&#39; inertia tensor.</span>
<span class="sd">    </span>
<span class="sd">    :param pix: cell coordinates ([x1,...,xn],[y1,...,yn])</span>
<span class="sd">    :return: unit vector of the cell orientation</span>

<span class="sd">    .. seealso:: :func:`~SimUtils.AnalysisUtils.getCellInertiaTensor`        </span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="p">[</span><span class="n">V</span><span class="p">,</span><span class="n">D</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">getCellInertiaTensor</span><span class="p">(</span><span class="n">pix</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">D</span><span class="p">[</span><span class="n">V</span><span class="o">==</span><span class="nb">max</span><span class="p">(</span><span class="n">V</span><span class="p">)][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">D</span><span class="p">[</span><span class="n">V</span><span class="o">==</span><span class="nb">max</span><span class="p">(</span><span class="n">V</span><span class="p">)][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>

<span class="k">def</span> <span class="nf">getCellOrientationDiff</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate angle between to cell orientations </span>
<span class="sd">    </span>
<span class="sd">    :param v1: orientation vector of the first cell</span>
<span class="sd">    :param v2: orientation vector of the second cell</span>
<span class="sd">    :return: angle in radians on interval :math:`[0,\pi]`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">da</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">da</span> <span class="o">&gt;</span> <span class="o">.</span><span class="mi">5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
        <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">da</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">da</span>
    
<span class="k">def</span> <span class="nf">calcPerimeter</span><span class="p">(</span><span class="n">im</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate perimeter length </span>
<span class="sd">    </span>
<span class="sd">    :param im: boolean image; 1 for occupied pixels and 0 for empty pixels.</span>
<span class="sd">    :type im: numpy array</span>
<span class="sd">    :return: perimeter length</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~SimUtils.AnalysisUtils.getPerimeter`    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">getPerimeter</span><span class="p">(</span><span class="n">im</span><span class="p">))</span>    

<span class="k">def</span> <span class="nf">getPerimeter</span><span class="p">(</span><span class="n">im</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate perimeter of the object described by the non-zero pixels. This is done by finding the border pixels using using :func:`mahotas.labeled.borders` which returns an image with 1 at border pixels and zero at all other pixels. Note that :func:`mahotas.labeled.borders` finds border pixels at both sides of the interface, here we only use the pixels on the outside (im==0).   </span>
<span class="sd">    </span>
<span class="sd">    :param im: boolean image; 1 for occupied pixels and 0 for empty pixels.</span>
<span class="sd">    :type im: numpy array</span>
<span class="sd">    :return: image with 1 at border pixels and 0 at all other pixels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">imtemp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">imtemp</span><span class="p">[</span><span class="n">imtemp</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">bimall</span> <span class="o">=</span> <span class="n">labeled</span><span class="o">.</span><span class="n">borders</span><span class="p">(</span><span class="n">imtemp</span><span class="p">)</span>
    <span class="c"># labeled.borders returns pixels at both sides of the interface, we only use the inner perimeter.</span>
    <span class="n">bimall</span><span class="p">[</span><span class="n">im</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">bimall</span>

<span class="k">def</span> <span class="nf">_hasMediumNeighbor</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="n">tau</span><span class="p">,</span><span class="n">medium</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">tau</span><span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="n">medium</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_countMediumNeighbor</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="n">tau</span><span class="p">,</span><span class="n">medium</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tau</span><span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="n">medium</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">countMediumNeighbor</span><span class="p">(</span><span class="n">cellim</span><span class="p">,</span><span class="n">tau</span><span class="p">,</span><span class="n">medium</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Count number of pixels with medium neighbors and the total number of medium pixels that are seen by the border pixels.</span>
<span class="sd">    </span>
<span class="sd">    :param cellim: boolean image; 1 for occupied pixels and 0 for empty pixels.</span>
<span class="sd">    :type cellim: numpy array</span>
<span class="sd">    :param tau: array with cell types</span>
<span class="sd">    :type tau: numpy array</span>
<span class="sd">    :param medium: type of medium</span>
<span class="sd">    :type medium: int</span>
<span class="sd">    :return: number of cells that has at least one medium neighbor, total number of medium neighbors that pixels can be copied to.</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">per</span> <span class="o">=</span> <span class="n">getPerimeter</span><span class="p">(</span><span class="n">cellim</span><span class="p">)</span>
    <span class="n">pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">per</span><span class="p">)</span>
    <span class="n">ncellsWithMedium</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">totalMediumNeighbor</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pix</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">_countMediumNeighbor</span><span class="p">([</span><span class="n">pix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">pix</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]],</span><span class="n">tau</span><span class="p">,</span><span class="n">medium</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ncellsWithMedium</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">totalMediumNeighbor</span> <span class="o">+=</span> <span class="n">n</span> 
    <span class="k">return</span> <span class="n">ncellsWithMedium</span><span class="p">,</span><span class="n">totalMediumNeighbor</span>

<span class="k">def</span> <span class="nf">calcInterfaceTypes</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">tau</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate perimeter of the object described by the non-zero pixels. This is done by finding the border pixels using using :func:`mahotas.labeled.borders` which returns an image with 1 at border pixels and zero at all other pixels. Note that :func:`mahotas.labeled.borders` finds border pixels at both sides of the interface, here we only use the pixels on the outside (im==0). </span>

<span class="sd">    :param im: boolean image; 1 for occupied pixels and 0 for empty pixels.</span>
<span class="sd">    :type im: numpy array</span>
<span class="sd">    :param tau: array with cell types</span>
<span class="sd">    :type tau: numpy array</span>
<span class="sd">    :return: list with the type of each border pixel</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">imtemp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">imtemp</span><span class="p">[</span><span class="n">imtemp</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">bimall</span> <span class="o">=</span> <span class="n">labeled</span><span class="o">.</span><span class="n">borders</span><span class="p">(</span><span class="n">imtemp</span><span class="p">)</span>
    <span class="c"># labeled.borders returns pixels at both sides of the interface, we only use the outer perimeter.</span>
    <span class="n">bimall</span><span class="p">[</span><span class="n">im</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">tau</span><span class="p">[</span><span class="n">bimall</span><span class="p">]</span>

<div class="viewcode-block" id="calcClusterInterfaces"><a class="viewcode-back" href="../../AnalysisUtils.html#SimUtils.AnalysisUtils.calcClusterInterfaces">[docs]</a><span class="k">def</span> <span class="nf">calcClusterInterfaces</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">clusters</span><span class="p">,</span><span class="n">cells</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate length of cell-cluster interface and ECM-cluster interface.</span>
<span class="sd">    For this we use the folowing perimeters:</span>
<span class="sd">    </span>
<span class="sd">        - :math:`p_{\\text{M}}` = perimeter morphology</span>
<span class="sd">        - :math:`p_{\\text{C}}` = perimeter cluster</span>
<span class="sd">        - :math:`p_{\\text{NC}}` = perimeter of morppology WITHOUT the cluster</span>
<span class="sd">    </span>
<span class="sd">    Not the total interface between the cluster and other cells is: :math:`p_\\text{cell,cluster} = \\frac{p_\\text{C}+p_\\text{NC}-p_\\text{M}}{2}\\;` and the interface between the cluster and ECM is: :math:`p_{\\text{ecm,cluster}} = p_\\text{C}-p_\\text{cell,cluster}`.</span>

<span class="sd">    :param sigma: CPM grid</span>
<span class="sd">    :type sigma: numpy array</span>
<span class="sd">    :param clusters: dictionary with cluster id as key and :class:Cluster instaces as values</span>
<span class="sd">    :param cells: list of :class:`~SimUtils.Cell.ClusterCell` instances</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># calcuate pM</span>
    <span class="n">pM</span> <span class="o">=</span> <span class="n">calcPerimeter</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
    <span class="c"># calculate perimeters per cluster</span>
    <span class="k">for</span> <span class="nb">id</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="n">clusters</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="n">imC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">imNC</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">imNC</span><span class="p">[</span><span class="n">imNC</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">imC</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="n">cid</span><span class="p">]</span><span class="o">.</span><span class="n">pix</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">imNC</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="n">cid</span><span class="p">]</span><span class="o">.</span><span class="n">pix</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">c</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="n">calcPerimeter</span><span class="p">(</span><span class="n">imC</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="n">cellinterface</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">perimeter</span><span class="o">+</span><span class="n">calcPerimeter</span><span class="p">(</span><span class="n">imNC</span><span class="p">)</span><span class="o">-</span><span class="n">pM</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="n">ecminterface</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">perimeter</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">cellinterface</span>  
</div>
<div class="viewcode-block" id="getRelativeDirField"><a class="viewcode-back" href="../../AnalysisUtils.html#SimUtils.AnalysisUtils.getRelativeDirField">[docs]</a><span class="k">def</span> <span class="nf">getRelativeDirField</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">cells</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate field with relative director for each pixel. The relative director is the difference to the angle of the cell at that pixel and the relative director on the pixel. Pixels with high values represent unordered areas, such as branchpoints.</span>
<span class="sd">    </span>
<span class="sd">    :param sigma: CPM grid</span>
<span class="sd">    :type sigma: numpy array</span>
<span class="sd">    :param cells: dict with cell identifiers as keys and :class:`~SimUtils.Cell.ClusterCell` instances as values</span>
<span class="sd">    :param r: radius used for calculating the director</span>
<span class="sd">    :type r: int</span>
<span class="sd">    :return: field with relative director values</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~SimUtils.AnalysisUtils.getDirectorPF`</span>
<span class="sd">    .. seealso:: :func:`~SimUtils.AnalysisUtils.getDirectorPF`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">getAngleField</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>    
    <span class="nb">dir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>    
    <span class="c"># calculate director at every pixel</span>
    <span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span>    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sigma</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">dir</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">getDirectorPF</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="n">r</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">angles</span><span class="p">,</span><span class="n">weighted</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="c"># calcuate local difference between director and cell angles</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
    <span class="n">field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="nb">dir</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>
    <span class="n">field</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">field</span><span class="o">&gt;</span><span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">field</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">field</span><span class="o">&gt;</span><span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">field</span>
</div>
<div class="viewcode-block" id="getPixelClusters"><a class="viewcode-back" href="../../AnalysisUtils.html#SimUtils.AnalysisUtils.getPixelClusters">[docs]</a><span class="k">def</span> <span class="nf">getPixelClusters</span><span class="p">(</span><span class="n">field</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">th</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span><span class="n">minlabsize</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">opendisk</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get clusters of pixels for a single morphology. Clusters are detected with the following steps:</span>
<span class="sd">        </span>
<span class="sd">        1) Remove all pixels that have a value in field higher than a given threshold.</span>
<span class="sd">        2) Detect blobs in remaining image with a labeling algorith:</span>
<span class="sd">            a. an opening operation may be performed before labeling.        </span>
<span class="sd">            b. areas smaller than a given size are ignored;</span>
<span class="sd">    </span>
<span class="sd">    :param field: numpy array with values on which data is seperated</span>
<span class="sd">    :param sigma: CPM grid</span>
<span class="sd">    :param th: threshold value for step 1</span>
<span class="sd">    :param minlabsize: labelled areas smaller than this value are ignored (2b)</span>
<span class="sd">    :param opendisk: disk size for opening operation (2a)</span>
<span class="sd">    :param mincellsize: minimal fraction of the cell that must be on the labelled area to be added to the cluster</span>
<span class="sd">    :return: dictionary: {clusterid : list of cluster pixels}</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~SimUtils.AnalysisUtils.getBlobs`</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">cfield</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
    <span class="c">#~ print np.unique(field)</span>
    <span class="n">cfield</span><span class="p">[</span><span class="n">field</span><span class="o">&lt;</span><span class="n">th</span><span class="p">]</span> <span class="o">=</span> <span class="mi">120</span>
    <span class="n">cfield</span><span class="p">[</span><span class="n">sigma</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">labnum</span><span class="p">,</span><span class="n">lab</span> <span class="o">=</span> <span class="n">getBlobs</span><span class="p">(</span><span class="n">cfield</span><span class="p">,</span><span class="n">minsize</span><span class="o">=</span><span class="n">minlabsize</span><span class="p">,</span><span class="n">opendisk</span><span class="o">=</span><span class="n">opendisk</span><span class="p">)</span>
    <span class="n">clusters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">labnum</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">clusters</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lab</span><span class="o">==</span><span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">clusters</span>    
</div>
<div class="viewcode-block" id="getCellClusters"><a class="viewcode-back" href="../../AnalysisUtils.html#SimUtils.AnalysisUtils.getCellClusters">[docs]</a><span class="k">def</span> <span class="nf">getCellClusters</span><span class="p">(</span><span class="n">field</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">th</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span><span class="n">minlabsize</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">opendisk</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">mincellsize</span><span class="o">=.</span><span class="mi">25</span><span class="p">):</span>    
    <span class="sd">&quot;&quot;&quot; Get clusters for a single morphology. Clusters are detected with the following steps:</span>
<span class="sd">        </span>
<span class="sd">        1) Remove all pixels that have a value in field higher than a given threshold.</span>
<span class="sd">        2) Detect blobs in remaining image with a labeling algorith:</span>
<span class="sd">            a. an opening operation may be performed before labeling.        </span>
<span class="sd">            b. areas smaller than a given size are ignored;</span>
<span class="sd">        3) Map each blob on the CPM grid:</span>
<span class="sd">            a. at least a given fraction of the cell must be on the labeled area.</span>
<span class="sd">        4) Check for cells in multiple clusters:</span>
<span class="sd">            a. remove cell from all but biggest cluster;</span>
<span class="sd">            b. remove cluster if it is empty after (a).</span>
<span class="sd">    </span>
<span class="sd">    :param field: numpy array with values on which data is seperated</span>
<span class="sd">    :param cells: dict with cell identifiers as keys and :class:`~SimUtils.Cell.ClusterCell` instances as values</span>
<span class="sd">    :param sigma: CPM grid</span>
<span class="sd">    :param th: threshold value for step 1</span>
<span class="sd">    :param minlabsize: labelled areas smaller than this value are ignored (2b)</span>
<span class="sd">    :param opendisk: disk size for opening operation (2a)</span>
<span class="sd">    :param mincellsize: minimal fraction of the cell that must be on the labelled area to be added to the cluster</span>
<span class="sd">    :return: dictionary with cluster id as key and :class:`~SimUtils.AnalysisUtils.Cluster` instances</span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: :func:`~SimUtils.AnalysisUtils.getBlobs`, :class:`~SimUtils.AnalysisUtils.Cluster` </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cfield</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
    <span class="n">cfield</span><span class="p">[</span><span class="n">field</span><span class="o">&lt;</span><span class="n">th</span><span class="p">]</span> <span class="o">=</span> <span class="mi">120</span>
    <span class="n">cfield</span><span class="p">[</span><span class="n">sigma</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">celldict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">cellid</span><span class="p">,[])</span> <span class="k">for</span> <span class="n">cellid</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">sigma</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">labnum</span><span class="p">,</span><span class="n">lab</span> <span class="o">=</span> <span class="n">getBlobs</span><span class="p">(</span><span class="n">cfield</span><span class="p">,</span><span class="n">minsize</span><span class="o">=</span><span class="n">minlabsize</span><span class="p">,</span><span class="n">opendisk</span><span class="o">=</span><span class="n">opendisk</span><span class="p">)</span>
    <span class="n">clusters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">labnum</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">Cluster</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">cellpos</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lab</span><span class="o">==</span><span class="n">n</span><span class="p">)])</span>
        <span class="k">for</span> <span class="n">cellid</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">sigma</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">cellpos</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">cellid</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">mincellsize</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sigma</span><span class="o">==</span><span class="n">cellid</span><span class="p">):</span>                
                <span class="n">celldict</span><span class="p">[</span><span class="n">cellid</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">addCell</span><span class="p">(</span><span class="n">cellid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">getClusterSize</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">clusters</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
    <span class="n">nolab</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">cellid</span><span class="p">,</span><span class="n">labels</span> <span class="ow">in</span> <span class="n">celldict</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nolab</span> <span class="o">+=</span> <span class="mi">1</span>           
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">lc</span> <span class="o">=</span> <span class="p">[</span><span class="n">clusters</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span><span class="o">.</span><span class="n">getClusterSize</span><span class="p">()</span> <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]</span>
            <span class="n">cmax</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">lc</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">lc</span><span class="p">))]</span>
            <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lab</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">cmax</span><span class="p">:</span>
                    <span class="n">empty</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span><span class="o">.</span><span class="n">removeCell</span><span class="p">(</span><span class="n">cellid</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">empty</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">clusters</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">clusters</span>
</div>
<div class="viewcode-block" id="getAngleField"><a class="viewcode-back" href="../../AnalysisUtils.html#SimUtils.AnalysisUtils.getAngleField">[docs]</a><span class="k">def</span> <span class="nf">getAngleField</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get field with the cell angles </span>
<span class="sd">    </span>
<span class="sd">    :param sigma: CPM grid</span>
<span class="sd">    :return: field with angles</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>    
    <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">angles</span><span class="p">[</span><span class="n">sigma</span><span class="o">==</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">getCellAngle</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sigma</span><span class="o">==</span><span class="nb">id</span><span class="p">))</span>
    <span class="c">#~ angles[angles&gt;90] = angles[angles&gt;90]-180</span>
    <span class="k">return</span> <span class="n">angles</span>
</div>
<div class="viewcode-block" id="calcMSDTransForCellTC"><a class="viewcode-back" href="../../AnalysisUtils.html#SimUtils.AnalysisUtils.calcMSDTransForCellTC">[docs]</a><span class="k">def</span> <span class="nf">calcMSDTransForCellTC</span><span class="p">(</span><span class="n">com</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate the translational MSD for a single object.</span>
<span class="sd">    </span>
<span class="sd">    :param com: list of centers of mass at each time step</span>
<span class="sd">    :return: list with MSD for each time step</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">com</span><span class="o">-</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="calcMSDRotForCellTC"><a class="viewcode-back" href="../../AnalysisUtils.html#SimUtils.AnalysisUtils.calcMSDRotForCellTC">[docs]</a><span class="k">def</span> <span class="nf">calcMSDRotForCellTC</span><span class="p">(</span><span class="n">vecset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate the rotational MSD for a single object.</span>
<span class="sd">    </span>
<span class="sd">    :param vecset: list of orientation vectors for each time step</span>
<span class="sd">    :return: list with MSD for each time step</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c"># 1) Calculate angles between two vectors of consecutive time steps: $a$, this is used to find the best fitting orientation of each cell:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">angle</span><span class="p">(</span><span class="n">vecset</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">vecset</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">vecset</span><span class="p">))])</span>
    <span class="c"># Find all indices in $a$ where the $a &gt; \frac{1}{2}\pi$; here the opposite orientation should be used</span>
    <span class="c"># Rotate the vector corresponding to that angle 180 degrees.</span>
    <span class="c"># Update angles that are calculated with that vector.</span>
    <span class="c"># Repeat these steps untill all angles are correct.</span>
    <span class="c"># Now we have a set of vectors which in which all cells have the most likely orientation: vecset</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">a</span><span class="o">&gt;.</span><span class="mi">5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">a</span><span class="o">&gt;.</span><span class="mi">5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">vecset</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">vecset</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">vecset</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">vecset</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">+</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">vecset</span><span class="p">):</span>
            <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">vecset</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span><span class="n">vecset</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c"># 2) Calculate the angle between the possitive x-axis and each vector</span>
    <span class="n">xa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">vecset</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">vecset</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
    <span class="c"># Remap these angles from the [0,-pi] domain to the [pi,2pi] domain.</span>
    <span class="n">xa</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">xa</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">+</span><span class="n">xa</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">xa</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)]</span>
    
    <span class="c"># 3) Calculate differences between consecutive angles</span>
    <span class="c"># calculate differences between angles</span>
    <span class="n">da</span> <span class="o">=</span> <span class="n">xa</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">xa</span><span class="p">)]</span> <span class="o">-</span> <span class="n">xa</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c"># detect transition over 2*np.pi and correct the angular differences</span>
    <span class="n">da</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">da</span><span class="o">&lt;-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">+</span><span class="n">da</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">da</span><span class="o">&lt;-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)]</span>
    <span class="n">da</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">da</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">+</span><span class="n">da</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">da</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)]</span>
    <span class="c"># summarize all angular differences to get a(t)-a(0) = sum(a(t)-a(t-1)) for eacht t</span>
    
    <span class="c"># 4) Calculate cumulative sum of the angles and square</span>
    <span class="n">sda</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">da</span><span class="p">)</span>   
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span><span class="n">sda</span><span class="p">)),</span><span class="mi">2</span><span class="p">)</span>
</div>
<span class="k">def</span> <span class="nf">getNeighborsForCell</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">cellid</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get list of cell id&#39;s of the cells that are neighbors of cellid</span>
<span class="sd">    </span>
<span class="sd">    :param sigma: CPM grid</span>
<span class="sd">    :param cellid: id of the cell for which the neighbors are returned</span>
<span class="sd">    :return: list with cell id&#39;s of the neighbors of cellid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">neighbormap</span> <span class="o">=</span> <span class="n">labeled</span><span class="o">.</span><span class="n">borders</span><span class="p">(</span><span class="n">sigma</span><span class="o">==</span><span class="n">cellid</span><span class="p">)</span>
    <span class="n">nb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">neighbormap</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">nb</span><span class="p">[(</span><span class="n">nb</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">nb</span><span class="o">!=</span><span class="n">cellid</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">getNeighborsFromSigma</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get neighbors based on the CPM grid</span>
<span class="sd">    </span>
<span class="sd">    :param sigma: CPM grid</span>

<span class="sd">    :return: dictionary with cellid:[neighbors]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">neighbors</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">cellid</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cellid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">neighbors</span><span class="p">[</span><span class="n">cellid</span><span class="p">]</span> <span class="o">=</span> <span class="n">getNeighborsForCell</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">cellid</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">neighbors</span>

<span class="k">class</span> <span class="nc">TipFinder</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Class to find cells on the end points of sprouts </span>
<span class="sd">    </span>
<span class="sd">    :param sigma: CPM grid</span>
<span class="sd">    :param tau: type grid</span>
<span class="sd">    :param nodes: dictionary with {nodeid : (x,y)}</span>
<span class="sd">    :param edges: list with edges [(nodeid_soure,nodeid_target)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">tau</span><span class="p">,</span><span class="n">nodes</span><span class="p">,</span><span class="n">edges</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buildCellGraph</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">tau</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buildSkeletonGraph</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">nodes</span><span class="p">,</span><span class="n">edges</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_buildCellGraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">tau</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pygraph.classes.graph</span> <span class="kn">import</span> <span class="n">graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cg</span> <span class="o">=</span> <span class="n">graph</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">cellid</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cellid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="nb">type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">tau</span><span class="p">[</span><span class="n">sigma</span><span class="o">==</span><span class="n">cellid</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">getCoM</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sigma</span><span class="o">==</span><span class="n">cellid</span><span class="p">))</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;type&#39;</span><span class="p">:</span><span class="nb">type</span><span class="p">,</span><span class="s">&#39;pos&#39;</span><span class="p">:</span><span class="n">pos</span><span class="p">,</span><span class="s">&#39;size&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;color&#39;</span><span class="p">:(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cg</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">cellid</span><span class="p">,</span><span class="n">attrs</span><span class="o">=</span><span class="p">[</span><span class="n">attr</span><span class="p">])</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">getNeighborsFromSigma</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
        <span class="k">for</span> <span class="nb">id</span><span class="p">,</span><span class="n">neighbors</span> <span class="ow">in</span> <span class="n">edges</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cg</span><span class="o">.</span><span class="n">has_edge</span><span class="p">((</span><span class="nb">id</span><span class="p">,</span><span class="n">n</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cg</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="nb">id</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
        
    <span class="k">def</span> <span class="nf">_buildSkeletonGraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">nodes</span><span class="p">,</span><span class="n">edges</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pygraph.classes.graph</span> <span class="kn">import</span> <span class="n">graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sg</span> <span class="o">=</span> <span class="n">graph</span><span class="p">()</span>       
        <span class="n">idmap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">if</span> <span class="nb">id</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">sigma</span><span class="p">[(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">5</span><span class="p">):(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">5</span><span class="p">),(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">5</span><span class="p">):(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">5</span><span class="p">)]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
                <span class="n">ids</span> <span class="o">=</span> <span class="n">ids</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)]</span>
                <span class="nb">id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ids</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ids</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;pos&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">cg</span><span class="o">.</span><span class="n">node_attributes</span><span class="p">(</span><span class="nb">id</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;pos&#39;</span><span class="p">],</span><span class="s">&#39;size&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;color&#39;</span><span class="p">:(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)}</span>
            <span class="n">idmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">id</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="nb">id</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">attrs</span><span class="o">=</span><span class="p">[</span><span class="n">attr</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">id1</span> <span class="o">=</span> <span class="n">idmap</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">id2</span> <span class="o">=</span> <span class="n">idmap</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">id1</span> <span class="o">==</span> <span class="n">id2</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="o">.</span><span class="n">has_edge</span><span class="p">((</span><span class="n">id1</span><span class="p">,</span><span class="n">id2</span><span class="p">)):</span>
                    <span class="c">#~ print (id1,id2)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="n">id1</span><span class="p">,</span><span class="n">id2</span><span class="p">))</span>
        <span class="c">#~ print &#39;-----&#39;</span>

    <span class="k">def</span> <span class="nf">findTips</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">source</span><span class="p">,</span><span class="n">guess</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Find cells at the tip of the branch from source to guess</span>
<span class="sd">        </span>
<span class="sd">        - Calculate the shortest path from source to all other nodes.</span>
<span class="sd">        - Set the reference distance to the distance from source to guess (d) and add guess to tip nodes.</span>
<span class="sd">        - Visit all neighbors of guess and calculate the shortest path from neighbor to source (spn).</span>
<span class="sd">            </span>
<span class="sd">            * Check if we stumbled upon another node in the skeleton graph. If this happened we are walking over the wrong edge.</span>
<span class="sd">            * If spn &gt; d: </span>
<span class="sd">                </span>
<span class="sd">                + replace tip nodes with neighbor;</span>
<span class="sd">                + set d to spn;</span>
<span class="sd">                + clear list of nodes to visit next iteration (nnextNodes);</span>
<span class="sd">                + add all unvisited neighbors of neighbor nnextNodes.</span>
<span class="sd">                </span>
<span class="sd">            * If spn = d: </span>
<span class="sd">                </span>
<span class="sd">                + add neighbor to tip nodes;</span>
<span class="sd">                + add all unvisited neighbors of neighbor nnextNodes.        </span>
<span class="sd">                </span>
<span class="sd">        :return: list of cell identifiers of the cells at the end point</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pygraph.algorithms.minmax</span> <span class="kn">import</span> <span class="n">shortest_path</span>                
        <span class="n">sp</span> <span class="o">=</span> <span class="n">shortest_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cg</span><span class="p">,</span><span class="n">source</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">guess</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sp</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="n">guess</span><span class="p">]</span>
        <span class="n">nextNodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cg</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">guess</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nextNodes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">print</span> <span class="n">source</span><span class="p">,</span><span class="n">guess</span><span class="p">,</span><span class="n">nextNodes</span>
        <span class="n">prevNodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">guess</span><span class="p">]</span>
        <span class="n">tipNodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">guess</span><span class="p">]</span>
        <span class="n">endpoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">wrongPath</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">nextNodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nnextNodes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nextNodes</span><span class="p">:</span>
                <span class="n">prevNodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>        
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nextNodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="ow">and</span> <span class="p">((</span><span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">guess</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">source</span><span class="p">)):</span>
                    <span class="c">#~ print &#39;I should not be here, break and see wat whe got&#39;</span>
                    <span class="n">wrongPath</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">sp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                    <span class="n">nnextNodes</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">tipNodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span>
                    <span class="n">nadd</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cg</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">nn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">prevNodes</span><span class="p">:</span>
                            <span class="n">nnextNodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nn</span><span class="p">)</span>
                            <span class="n">nadd</span><span class="o">+=</span><span class="mi">1</span>
                    <span class="k">if</span> <span class="n">nadd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">sp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="n">d</span><span class="p">:</span>
                    <span class="n">tipNodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="n">nadd</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cg</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">nn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">prevNodes</span><span class="p">:</span>                    
                            <span class="n">nnextNodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nn</span><span class="p">)</span>
                            <span class="n">nadd</span><span class="o">+=</span><span class="mi">1</span>
                    <span class="k">if</span> <span class="n">nadd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>                         
            <span class="n">nextNodes</span> <span class="o">=</span> <span class="n">nnextNodes</span>
        <span class="k">if</span> <span class="n">wrongPath</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">endpoints</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tipNodes</span>
    
    <span class="k">def</span> <span class="nf">findAllCellsOnTips</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Find all cells at end points in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Iterate over all edges:</span>
<span class="sd">        - If edge connects node of order 1 with another node</span>
<span class="sd">            * the node with order one is used as the initial guess for the tip node;</span>
<span class="sd">            * the other node is the source node, from where we start looking for the tip node;</span>
<span class="sd">            * if both nodes have order 1, we look for the tip twice, once with the first node as source and the second as guess, and vice versa;</span>
<span class="sd">        - </span>
<span class="sd">        - for all edges that connect an end point (node with degree 1) to another node</span>
<span class="sd">        </span>
<span class="sd">        :return: dictionary with (sigma,tau) </span>
<span class="sd">        </span>
<span class="sd">        .. seealso:: :func:`~SimUtils.AnalysisUtils.TipFinder.findTips`</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">tips</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">vsources</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">vguesses</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n1</span><span class="p">,</span><span class="n">n2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
            <span class="c">#~ print n1,n2</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">n1</span> <span class="ow">in</span> <span class="n">vsources</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">n2</span> <span class="ow">in</span> <span class="n">vguesses</span><span class="p">))</span> <span class="ow">or</span> <span class="p">((</span><span class="n">n2</span> <span class="ow">in</span> <span class="n">vsources</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">n1</span> <span class="ow">in</span> <span class="n">vguesses</span><span class="p">)):</span>
                <span class="k">continue</span>
            <span class="n">guess</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">source</span> <span class="o">=</span> <span class="bp">None</span>            
            <span class="n">twoWay</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">tipNodes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="o">.</span><span class="n">node_order</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="o">.</span><span class="n">node_order</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">guess</span> <span class="o">=</span> <span class="n">n1</span>
                <span class="n">source</span> <span class="o">=</span> <span class="n">n2</span>
                <span class="c">#~ tipNodes = self.findTips(n2,n1)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="o">.</span><span class="n">node_order</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="o">.</span><span class="n">node_order</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>          
                <span class="n">guess</span> <span class="o">=</span> <span class="n">n2</span>
                <span class="n">source</span> <span class="o">=</span> <span class="n">n1</span>
                <span class="c">#~ tipNodes = self.findTips(n1,n2)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="o">.</span><span class="n">node_order</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="o">.</span><span class="n">node_order</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">guess</span> <span class="o">=</span> <span class="n">n1</span>
                <span class="n">source</span> <span class="o">=</span> <span class="n">n2</span>
                <span class="n">twoWay</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">guess</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>                 
                <span class="k">if</span> <span class="ow">not</span> <span class="n">twoWay</span><span class="p">:</span>
                    <span class="n">tipNodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findTips</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">guess</span><span class="p">)</span>
                    <span class="n">vsources</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
                    <span class="n">vguesses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">guess</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tipNodes</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">t1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findTips</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">guess</span><span class="p">)</span>
                    <span class="n">t2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findTips</span><span class="p">(</span><span class="n">guess</span><span class="p">,</span><span class="n">source</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">t1</span><span class="p">:</span>
                        <span class="n">tipNodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">t2</span><span class="p">:</span>
                        <span class="n">tipNodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>    
                    <span class="n">vsources</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
                    <span class="n">vguesses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>    
                    <span class="n">vsources</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">guess</span><span class="p">)</span>
                    <span class="n">vguesses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">guess</span><span class="p">)</span>  
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">tipNodes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tips</span><span class="p">:</span>
                        <span class="n">tips</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">tipdict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tips</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tipdict</span><span class="p">:</span>
                <span class="n">tipdict</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cg</span><span class="o">.</span><span class="n">node_attributes</span><span class="p">(</span><span class="n">t</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;type&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">tipdict</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../SimUtils.html">OpenSimUtils 1.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Margriet Palm.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>